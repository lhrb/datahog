shadow$provide.module$node_modules$$codemirror$rangeset$dist$index_cjs=function(global,require,module,exports){function cmpRange(a,b){return a.from-b.from||a.value.startSide-b.value.startSide}function findSharedChunks(a,b){let inA=new Map;for(var set$jscomp$0 of a)for(a=0;a<set$jscomp$0.chunk.length;a++)500>set$jscomp$0.chunk[a].maxPoint&&inA.set(set$jscomp$0.chunk[a],set$jscomp$0.chunkPos[a]);set$jscomp$0=new Set;for(let set of b)for(b=0;b<set.chunk.length;b++)inA.get(set.chunk[b])==set.chunkPos[b]&&
set$jscomp$0.add(set.chunk[b]);return set$jscomp$0}function heapBubble(heap,index){for(let cur=heap[index];;){let childIndex=(index<<1)+1;if(childIndex>=heap.length)break;let child=heap[childIndex];childIndex+1<heap.length&&0<=child.compare(heap[childIndex+1])&&(child=heap[childIndex+1],childIndex++);if(0>cur.compare(child))break;heap[childIndex]=cur;heap[index]=child;index=childIndex}}function compare(a,startA,b$jscomp$0,startB,length,comparator){a.goto(startA);b$jscomp$0.goto(startB);length=startB+
length;let pos=startB;for(startA=startB-startA;;){startB=a.to+startA-b$jscomp$0.to||a.endSide-b$jscomp$0.endSide;let end=0>startB?a.to+startA:b$jscomp$0.to,clipEnd=Math.min(end,length);if(a.point||b$jscomp$0.point)a.point&&b$jscomp$0.point&&(a.point==b$jscomp$0.point||a.point.eq(b$jscomp$0.point))||comparator.comparePoint(pos,clipEnd,a.point,b$jscomp$0.point);else{var JSCompiler_temp;if(JSCompiler_temp=clipEnd>pos){a:{JSCompiler_temp=a.active;var b=b$jscomp$0.active;if(JSCompiler_temp.length!=b.length)JSCompiler_temp=
!1;else{for(let i=0;i<JSCompiler_temp.length;i++)if(JSCompiler_temp[i]!=b[i]&&!JSCompiler_temp[i].eq(b[i])){JSCompiler_temp=!1;break a}JSCompiler_temp=!0}}JSCompiler_temp=!JSCompiler_temp}JSCompiler_temp&&comparator.compareRange(pos,clipEnd,a.active,b$jscomp$0.active)}if(end>length)break;pos=end;0>=startB&&a.next();0<=startB&&b$jscomp$0.next()}}function remove(array,index){for(let i=index,e=array.length-1;i<e;i++)array[i]=array[i+1];array.pop()}function insert(array,index,value){for(let i=array.length-
1;i>=index;i--)array[i+1]=array[i];array[index]=value}function findMinIndex(value,array){let found=-1,foundPos=1E9;for(let i=0;i<array.length;i++)0>(array[i]-foundPos||value[i].endSide-value[found].endSide)&&(found=i,foundPos=array[i]);return found}Object.defineProperty(exports,"__esModule",{value:!0});global=require("module$node_modules$$codemirror$state$dist$index_cjs");class RangeValue{eq(other){return this==other}range(from,to=from){return new Range(from,to,this)}}RangeValue.prototype.startSide=
RangeValue.prototype.endSide=0;RangeValue.prototype.point=!1;RangeValue.prototype.mapMode=global.MapMode.TrackDel;class Range{constructor(from,to,value){this.from=from;this.to=to;this.value=value}}class Chunk{constructor(from,to,value,maxPoint){this.from=from;this.to=to;this.value=value;this.maxPoint=maxPoint}get length(){return this.to[this.to.length-1]}findIndex(pos,end,side=1E9*end,startAt=0){if(0>=pos)return startAt;let arr=0>end?this.to:this.from;for(let lo=startAt,hi=arr.length;;){if(lo==hi)return lo;
startAt=lo+hi>>1;let diff=arr[startAt]-pos||(0>end?this.value[startAt].startSide:this.value[startAt].endSide)-side;if(startAt==lo)return 0<=diff?lo:hi;0<=diff?hi=startAt:lo=startAt+1}}between(offset,from,to,f){for(let i=this.findIndex(from,-1),e=this.findIndex(to,1,void 0,i);i<e;i++)if(!1===f(this.from[i]+offset,this.to[i]+offset,this.value[i]))return!1}map(offset,changes){let value=[],from=[],to=[],newPos=-1,maxPoint=-1;for(let i=0;i<this.value.length;i++){let val=this.value[i];var curFrom=this.from[i]+
offset,curTo=this.to[i]+offset;if(curFrom==curTo){curTo=changes.mapPos(curFrom,val.startSide,val.mapMode);if(null==curTo)continue;curFrom=curTo}else if(curFrom=changes.mapPos(curFrom,val.startSide),curTo=changes.mapPos(curTo,val.endSide),curFrom>curTo||curFrom==curTo&&0<val.startSide&&0>=val.endSide)continue;0>(curTo-curFrom||val.endSide-val.startSide)||(0>newPos&&(newPos=curFrom),val.point&&(maxPoint=Math.max(maxPoint,curTo-curFrom)),value.push(val),from.push(curFrom-newPos),to.push(curTo-newPos))}return{mapped:value.length?
new Chunk(from,to,value,maxPoint):null,pos:newPos}}}class RangeSet{constructor(chunkPos,chunk,nextLayer=RangeSet.empty,maxPoint){this.chunkPos=chunkPos;this.chunk=chunk;this.nextLayer=nextLayer;this.maxPoint=maxPoint}get length(){let last=this.chunk.length-1;return 0>last?0:Math.max(this.chunkEnd(last),this.nextLayer.length)}get size(){if(this==RangeSet.empty)return 0;let size=this.nextLayer.size;for(let chunk of this.chunk)size+=chunk.value.length;return size}chunkEnd(index){return this.chunkPos[index]+
this.chunk[index].length}update(updateSpec){let {add=[],sort=!1,filterFrom=0,filterTo=this.length}=updateSpec;updateSpec=updateSpec.filter;if(0==add.length&&!updateSpec)return this;sort&&add.slice().sort(cmpRange);if(this==RangeSet.empty)return add.length?RangeSet.of(add):this;let cur=(new LayerCursor(this,null,-1)).goto(0),i=0,spill=[],builder=new RangeSetBuilder;for(;cur.value||i<add.length;)if(i<add.length&&0<=(cur.from-add[i].from||cur.startSide-add[i].value.startSide)){let range=add[i++];builder.addInner(range.from,
range.to,range.value)||spill.push(range)}else if(1==cur.rangeIndex&&cur.chunkIndex<this.chunk.length&&(i==add.length||this.chunkEnd(cur.chunkIndex)<add[i].from)&&(!updateSpec||filterFrom>this.chunkEnd(cur.chunkIndex)||filterTo<this.chunkPos[cur.chunkIndex])&&builder.addChunk(this.chunkPos[cur.chunkIndex],this.chunk[cur.chunkIndex]))cur.nextChunk();else{if(!updateSpec||filterFrom>cur.to||filterTo<cur.from||updateSpec(cur.from,cur.to,cur.value))builder.addInner(cur.from,cur.to,cur.value)||spill.push(new Range(cur.from,
cur.to,cur.value));cur.next()}return builder.finishInner(this.nextLayer!=RangeSet.empty||spill.length?this.nextLayer.update({add:spill,filter:updateSpec,filterFrom,filterTo}):RangeSet.empty)}map(changes){if(0==changes.length||this==RangeSet.empty)return this;let chunks=[],chunkPos=[],maxPoint=-1;for(let i=0;i<this.chunk.length;i++){let start=this.chunkPos[i],chunk=this.chunk[i],touch=changes.touchesRange(start,start+chunk.length);if(!1===touch)maxPoint=Math.max(maxPoint,chunk.maxPoint),chunks.push(chunk),
chunkPos.push(changes.mapPos(start));else if(!0===touch){let {mapped,pos}=chunk.map(start,changes);mapped&&(maxPoint=Math.max(maxPoint,mapped.maxPoint),chunks.push(mapped),chunkPos.push(pos))}}changes=this.nextLayer.map(changes);return 0==chunks.length?changes:new RangeSet(chunkPos,chunks,changes,maxPoint)}between(from,to,f){if(this!=RangeSet.empty){for(let i=0;i<this.chunk.length;i++){let start=this.chunkPos[i],chunk=this.chunk[i];if(to>=start&&from<=start+chunk.length&&!1===chunk.between(start,
from-start,to-start,f))return}this.nextLayer.between(from,to,f)}}iter(from=0){return HeapCursor.from([this]).goto(from)}static iter(sets,from=0){return HeapCursor.from(sets).goto(from)}static compare(oldSets,newSets,textDiff,comparator,minPointSize=-1){let a=oldSets.filter(set=>500<=set.maxPoint||set!=RangeSet.empty&&0>newSets.indexOf(set)&&set.maxPoint>=minPointSize),b=newSets.filter(set=>500<=set.maxPoint||set!=RangeSet.empty&&0>oldSets.indexOf(set)&&set.maxPoint>=minPointSize),sharedChunks=findSharedChunks(a,
b),sideA=new SpanCursor(a,sharedChunks,minPointSize),sideB=new SpanCursor(b,sharedChunks,minPointSize);textDiff.iterGaps((fromA,fromB,length)=>compare(sideA,fromA,sideB,fromB,length,comparator));textDiff.empty&&0==textDiff.length&&compare(sideA,0,sideB,0,0,comparator)}static spans(sets,from,to,iterator,minPointSize=-1){sets=(new SpanCursor(sets,null,minPointSize)).goto(from);for(minPointSize=sets.openStart;;){let curTo=Math.min(sets.to,to);sets.point?(iterator.point(from,curTo,sets.point,sets.activeForPoint(sets.to),
minPointSize),minPointSize=sets.openEnd(curTo)+(sets.to>curTo?1:0)):curTo>from&&(iterator.span(from,curTo,sets.active,minPointSize),minPointSize=sets.openEnd(curTo));if(sets.to>to)break;from=sets.to;sets.next()}return minPointSize}static of(ranges,sort=!1){let build=new RangeSetBuilder;for(let range of ranges instanceof Range?[ranges]:sort?ranges.slice().sort(cmpRange):ranges)build.add(range.from,range.to,range.value);return build.finish()}}RangeSet.empty=new RangeSet([],[],null,-1);RangeSet.empty.nextLayer=
RangeSet.empty;class RangeSetBuilder{constructor(){this.chunks=[];this.chunkPos=[];this.chunkStart=-1;this.last=null;this.lastTo=this.lastFrom=-1E9;this.from=[];this.to=[];this.value=[];this.setMaxPoint=this.maxPoint=-1;this.nextLayer=null}finishChunk(newArrays){this.chunks.push(new Chunk(this.from,this.to,this.value,this.maxPoint));this.chunkPos.push(this.chunkStart);this.chunkStart=-1;this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint);this.maxPoint=-1;newArrays&&(this.from=[],this.to=[],
this.value=[])}add(from,to,value){this.addInner(from,to,value)||(this.nextLayer||(this.nextLayer=new RangeSetBuilder)).add(from,to,value)}addInner(from,to,value){let diff=from-this.lastTo||value.startSide-this.last.endSide;if(0>=diff&&0>(from-this.lastFrom||value.startSide-this.last.startSide))throw Error("Ranges must be added sorted by `from` position and `startSide`");if(0>diff)return!1;250==this.from.length&&this.finishChunk(!0);0>this.chunkStart&&(this.chunkStart=from);this.from.push(from-this.chunkStart);
this.to.push(to-this.chunkStart);this.last=value;this.lastFrom=from;this.lastTo=to;this.value.push(value);value.point&&(this.maxPoint=Math.max(this.maxPoint,to-from));return!0}addChunk(from,chunk){if(0>(from-this.lastTo||chunk.value[0].startSide-this.last.endSide))return!1;this.from.length&&this.finishChunk(!0);this.setMaxPoint=Math.max(this.setMaxPoint,chunk.maxPoint);this.chunks.push(chunk);this.chunkPos.push(from);let last=chunk.value.length-1;this.last=chunk.value[last];this.lastFrom=chunk.from[last]+
from;this.lastTo=chunk.to[last]+from;return!0}finish(){return this.finishInner(RangeSet.empty)}finishInner(next){this.from.length&&this.finishChunk(!1);if(0==this.chunks.length)return next;next=new RangeSet(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(next):next,this.setMaxPoint);this.from=null;return next}}class LayerCursor{constructor(layer,skip,minPoint,rank=0){this.layer=layer;this.skip=skip;this.minPoint=minPoint;this.rank=rank}get startSide(){return this.value?this.value.startSide:
0}get endSide(){return this.value?this.value.endSide:0}goto(pos,side=-1E9){this.chunkIndex=this.rangeIndex=0;this.gotoInner(pos,side,!1);return this}gotoInner(pos,side,forward){for(;this.chunkIndex<this.layer.chunk.length;){let next=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(next)||this.layer.chunkEnd(this.chunkIndex)<pos||next.maxPoint<this.minPoint))break;this.chunkIndex++;forward=!1}pos=this.chunkIndex==this.layer.chunk.length?0:this.layer.chunk[this.chunkIndex].findIndex(pos-
this.layer.chunkPos[this.chunkIndex],-1,side);if(!forward||this.rangeIndex<pos)this.rangeIndex=pos;this.next()}forward(pos,side){0>(this.to-pos||this.endSide-side)&&this.gotoInner(pos,side,!0)}next(){for(;;)if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1E9;this.value=null;break}else{let chunkPos=this.layer.chunkPos[this.chunkIndex],chunk=this.layer.chunk[this.chunkIndex];this.from=chunkPos+chunk.from[this.rangeIndex];this.to=chunkPos+chunk.to[this.rangeIndex];this.value=chunk.value[this.rangeIndex];
if(++this.rangeIndex==chunk.value.length){this.chunkIndex++;if(this.skip)for(;this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++;this.rangeIndex=0}if(0>this.minPoint||this.value.point&&this.to-this.from>=this.minPoint)break}}nextChunk(){this.chunkIndex++;this.rangeIndex=0;this.next()}compare(other){return this.from-other.from||this.startSide-other.startSide||this.to-other.to||this.endSide-other.endSide}}class HeapCursor{constructor(heap){this.heap=
heap}static from(sets,skip=null,minPoint=-1){let heap=[];for(let i=0;i<sets.length;i++)for(let cur=sets[i];cur!=RangeSet.empty;cur=cur.nextLayer)cur.maxPoint>=minPoint&&heap.push(new LayerCursor(cur,skip,minPoint,i));return 1==heap.length?heap[0]:new HeapCursor(heap)}get startSide(){return this.value?this.value.startSide:0}goto(pos,side=-1E9){for(let cur of this.heap)cur.goto(pos,side);for(pos=this.heap.length>>1;0<=pos;pos--)heapBubble(this.heap,pos);this.next();return this}forward(pos,side){for(var cur of this.heap)cur.forward(pos,
side);for(cur=this.heap.length>>1;0<=cur;cur--)heapBubble(this.heap,cur);0>(this.to-pos||this.value.endSide-side)&&this.next()}next(){if(0==this.heap.length)this.from=this.to=1E9,this.value=null,this.rank=-1;else{let top=this.heap[0];this.from=top.from;this.to=top.to;this.value=top.value;this.rank=top.rank;top.value&&top.next();heapBubble(this.heap,0)}}}class SpanCursor{constructor(sets,skip,minPoint){this.minPoint=minPoint;this.active=[];this.activeTo=[];this.activeRank=[];this.minActive=-1;this.point=
null;this.pointRank=this.pointFrom=0;this.to=-1E9;this.endSide=0;this.openStart=-1;this.cursor=HeapCursor.from(sets,skip,minPoint)}goto(pos,side=-1E9){this.cursor.goto(pos,side);this.active.length=this.activeTo.length=this.activeRank.length=0;this.minActive=-1;this.to=pos;this.endSide=side;this.openStart=-1;this.next();return this}forward(pos,side){for(;-1<this.minActive&&0>(this.activeTo[this.minActive]-pos||this.active[this.minActive].endSide-side);)this.removeActive(this.minActive);this.cursor.forward(pos,
side)}removeActive(index){remove(this.active,index);remove(this.activeTo,index);remove(this.activeRank,index);this.minActive=findMinIndex(this.active,this.activeTo)}addActive(trackOpen){let i=0,{value,to,rank}=this.cursor;for(;i<this.activeRank.length&&this.activeRank[i]<=rank;)i++;insert(this.active,i,value);insert(this.activeTo,i,to);insert(this.activeRank,i,rank);trackOpen&&insert(trackOpen,i,this.cursor.from);this.minActive=findMinIndex(this.active,this.activeTo)}next(){let from=this.to;var wasPoint=
this.point;this.point=null;let trackOpen=0>this.openStart?[]:null,trackExtra=0;for(;;){var a=this.minActive;if(-1<a&&0>(this.activeTo[a]-this.cursor.from||this.active[a].endSide-this.cursor.startSide)){if(this.activeTo[a]>from){this.to=this.activeTo[a];this.endSide=this.active[a].endSide;break}this.removeActive(a);trackOpen&&remove(trackOpen,a)}else if(this.cursor.value)if(this.cursor.from>from){this.to=this.cursor.from;this.endSide=this.cursor.startSide;break}else if(a=this.cursor.value,a.point)if(wasPoint&&
this.cursor.to==this.to&&this.cursor.from<this.cursor.to&&a.endSide==this.endSide)this.cursor.next();else{this.point=a;this.pointFrom=this.cursor.from;this.pointRank=this.cursor.rank;this.to=this.cursor.to;this.endSide=a.endSide;this.cursor.from<from&&(trackExtra=1);this.cursor.next();this.to>from&&this.forward(this.to,this.endSide);break}else this.addActive(trackOpen),this.cursor.next();else{this.to=this.endSide=1E9;break}}if(trackOpen){for(wasPoint=0;wasPoint<trackOpen.length&&trackOpen[wasPoint]<
from;)wasPoint++;this.openStart=wasPoint+trackExtra}}activeForPoint(to){if(!this.active.length)return this.active;let active=[];for(let i=0;i<this.active.length&&!(this.activeRank[i]>this.pointRank);i++)(this.activeTo[i]>to||this.activeTo[i]==to&&this.active[i].endSide>this.point.endSide)&&active.push(this.active[i]);return active}openEnd(to){let open=0;for(;open<this.activeTo.length&&this.activeTo[open]>to;)open++;return open}}exports.Range=Range;exports.RangeSet=RangeSet;exports.RangeSetBuilder=
RangeSetBuilder;exports.RangeValue=RangeValue}
//# sourceMappingURL=module$node_modules$$codemirror$rangeset$dist$index_cjs.js.map
