shadow$provide.module$node_modules$lezer_generator$dist$index_cjs=function(global,require,module,exports){function walkExprs(exprs,f){let result=null;for(let i=0;i<exprs.length;i++){let expr=exprs[i].walk(f);expr==exprs[i]||result||(result=exprs.slice(0,i));result&&result.push(expr)}return result||exprs}function exprEq(a,b){return a.constructor==b.constructor&&a.eq(b)}function exprsEq(a,b){return a.length==b.length&&a.every((e,i)=>exprEq(e,b[i]))}function maybeParens(node,parent){return node.prec<
parent.prec?"("+node.toString()+")":node.toString()}function hasProps(props){for(let _p in props)return!0;return!1}function cmpSet(a,b,cmp){if(a.length!=b.length)return a.length-b.length;for(let i=0;i<a.length;i++){let diff=cmp(a[i],b[i]);if(diff)return diff}return 0}function union(a,b){if(0==a.length||a==b)return b;if(0==b.length)return a;let result=a.slice();for(let value of b)a.includes(value)||result.push(value);return result.sort()}function charFor(n){return 65534<n?"∞":55296<=n&&57343>n?"\\u{"+
n.toString(16)+"}":String.fromCharCode(n)}function minimize(states,start){var partition=Object.create(null),byAccepting=Object.create(null);for(var state$jscomp$0 of states){var id=ids(state$jscomp$0.accepting);id=byAccepting[id]||(byAccepting[id]=[]);id.push(state$jscomp$0);partition[state$jscomp$0.id]=id}for(;;){byAccepting=!1;state$jscomp$0=Object.create(null);for(var state$jscomp$1 of states)if(!state$jscomp$0[state$jscomp$1.id]){var group=partition[state$jscomp$1.id];if(1==group.length)state$jscomp$0[group[0].id]=
group;else{id=[];a:for(var state$jscomp$2 of group){for(let p of id){b:if(group=p[0],state$jscomp$2.edges.length!=group.edges.length)group=!1;else{for(let i=0;i<state$jscomp$2.edges.length;i++){let eA=state$jscomp$2.edges[i],eB=group.edges[i];if(eA.from!=eB.from||eA.to!=eB.to||partition[eA.target.id]!=partition[eB.target.id]){group=!1;break b}}group=!0}if(group){p.push(state$jscomp$2);continue a}}id.push([state$jscomp$2])}1<id.length&&(byAccepting=!0);for(let p of id)for(let s of p)state$jscomp$0[s.id]=
p}}if(!byAccepting){for(let state of states)for(states=0;states<state.edges.length;states++)state$jscomp$1=state.edges[states],state$jscomp$2=partition[state$jscomp$1.target.id][0],state$jscomp$2!=state$jscomp$1.target&&(state.edges[states]=new Edge(state$jscomp$1.from,state$jscomp$1.to,state$jscomp$2));return partition[start.id][0]}partition=state$jscomp$0}}function exampleFromEdges(edges){let str="";for(let i=0;i<edges.length;i++)str+=String.fromCharCode(edges[i].from);return str}function ids(elts){let result=
"";for(let elt of elts)result.length&&(result+="-"),result+=elt.id;return result}function mergeEdges(edges){let separate=[],result=[];for(var edge$jscomp$0 of edges)separate.includes(edge$jscomp$0.from)||separate.push(edge$jscomp$0.from),separate.includes(edge$jscomp$0.to)||separate.push(edge$jscomp$0.to);separate.sort((a,b)=>a-b);for(edge$jscomp$0=1;edge$jscomp$0<separate.length;edge$jscomp$0++){let from=separate[edge$jscomp$0-1],to=separate[edge$jscomp$0],found=[];for(let edge of edges)if(edge.to>
from&&edge.from<to)for(let target of edge.target.closure())found.includes(target)||found.push(target);found.length&&result.push(new MergedEdge(from,to,found))}return result}function parseRule(input,named){let start=named?named.start:input.start;named=named||parseIdent(input);let props=parseProps(input),params=[];if(input.eat("\x3c"))for(;!input.eat("\x3e");)params.length&&input.expect(","),params.push(parseIdent(input));input=parseBracedExpr(input);return new RuleDeclaration(start,named,props,params,
input)}function parseProps(input){if("["!=input.type)return none$1;let props=[];for(input.expect("[");!input.eat("]");){props.length&&input.expect(",");var JSCompiler_temp_const=props,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.push;var JSCompiler_inline_result=input;let start=JSCompiler_inline_result.start,value=[],name=JSCompiler_inline_result.value,at="at"==JSCompiler_inline_result.type;JSCompiler_inline_result.eat("at")||JSCompiler_inline_result.eat("id")||JSCompiler_inline_result.unexpected();
if(JSCompiler_inline_result.eat("\x3d"))for(;;)if("string"==JSCompiler_inline_result.type||"id"==JSCompiler_inline_result.type)value.push(new PropPart(JSCompiler_inline_result.start,JSCompiler_inline_result.value,null)),JSCompiler_inline_result.next();else if(JSCompiler_inline_result.eat("."))value.push(new PropPart(JSCompiler_inline_result.start,".",null));else if(JSCompiler_inline_result.eat("{"))value.push(new PropPart(JSCompiler_inline_result.start,null,JSCompiler_inline_result.expect("id"))),
JSCompiler_inline_result.expect("}");else break;JSCompiler_inline_result=new Prop(start,at,name,value);JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,JSCompiler_inline_result)}return props}function parseBracedExpr(input){input.expect("{");let expr=parseExprChoice(input);input.expect("}");return expr}function parseExprInner(input){var start=input.start;if(input.eat("("))return start=parseExprChoice(input),input.expect(")"),start;if("string"==input.type){var value=input.value;input.next();
return 0==value.length?new SequenceExpression(start,none$1,[none$1,none$1]):new LiteralExpression(start,value)}if(input.eat("id","_"))return new AnyExpression(start);if("set"==input.type){value="!"==input.string[input.start];var unescaped=readString(input.value.replace(/\\.|-|"/g,m=>"-"==m?"﷚":'"'==m?'\\"':m));let ranges=[];for(let pos=0;pos<unescaped.length;){let code=unescaped.codePointAt(pos);pos+=65535<code?2:1;if(pos<unescaped.length-1&&"﷚"==unescaped[pos]){let end=unescaped.codePointAt(pos+
1);pos+=65535<end?3:2;end<code&&input.raise("Invalid character range",input.start);addRange(input,ranges,code,end+1)}else addRange(input,ranges,code,code+1)}input.next();return new SetExpression(start,ranges.sort((a,b)=>a[0]-b[0]),value)}if("at"!=input.type||"specialize"!=input.value&&"extend"!=input.value){if("["==input.type)return value=parseRule(input,new Identifier(start,"_anon")),value.params.length&&input.raise("Inline rules can't have parameters",value.start),new InlineRuleExpression(start,
value);value=parseIdent(input);if("["==input.type||"{"==input.type)return value=parseRule(input,value),value.params.length&&input.raise("Inline rules can't have parameters",value.start),new InlineRuleExpression(start,value);unescaped=null;input.eat(".")&&(unescaped=value,value=parseIdent(input));return new NameExpression(start,unescaped,value,parseArgs(input))}let {start:start$jscomp$0,value:value$jscomp$0}=input;input.next();start=parseProps(input);input.expect("\x3c");unescaped=parseExprChoice(input);
input.eat(",")?value=parseExprChoice(input):unescaped instanceof LiteralExpression?value=unescaped:input.raise(`@${value$jscomp$0} requires two arguments when its first argument isn't a literal string`);input.expect("\x3e");return new SpecializeExpression(start$jscomp$0,value$jscomp$0,start,unescaped,value)}function parseArgs(input){let args=[];if(input.eat("\x3c"))for(;!input.eat("\x3e");)args.length&&input.expect(","),args.push(parseExprChoice(input));return args}function addRange(input,ranges,
from,to){ranges.every(([a,b])=>b<=from||a>=to)||input.raise("Overlapping character range",input.start);ranges.push([from,to])}function parseExprSuffix(input){let start=input.start,expr=parseExprInner(input);for(;;){let kind=input.type;if(input.eat("*")||input.eat("?")||input.eat("+"))expr=new RepeatExpression(start,expr,kind);else return expr}}function endOfSequence(input){return"}"==input.type||")"==input.type||"|"==input.type||"/"==input.type||"/\\"==input.type||"{"==input.type||","==input.type||
"\x3e"==input.type}function parseExprSequence(input){let start=input.start,exprs=[],markers=[none$1];do{for(;;){let localStart=input.start,markerType;if(input.eat("~"))markerType="ambig";else if(input.eat("!"))markerType="prec";else break;markers[markers.length-1]=markers[markers.length-1].concat(new ConflictMarker(localStart,parseIdent(input),markerType))}if(endOfSequence(input))break;exprs.push(parseExprSuffix(input));markers.push(none$1)}while(!endOfSequence(input));return 1==exprs.length&&markers.every(ms=>
0==ms.length)?exprs[0]:new SequenceExpression(start,exprs,markers)}function parseExprChoice(input){let start=input.start;var left=parseExprSequence(input);if(!input.eat("|"))return left;left=[left];do left.push(parseExprSequence(input));while(input.eat("|"));return new ChoiceExpression(start,left)}function parseIdent(input){"id"!=input.type&&input.unexpected();let start=input.start,name=input.value;input.next();return new Identifier(start,name)}function parseExternalTokenSet(input){let tokens=[];
for(input.expect("{");!input.eat("}");){tokens.length&&input.eat(",");let id=parseIdent(input),props=parseProps(input);tokens.push({id,props})}return tokens}function parseExternalSpecialize(input,type,start){let token=parseBracedExpr(input),id=parseIdent(input);input.expect("id","from");let from=input.expect("string");return new ExternalSpecializeDeclaration(start,type,token,id,from,parseExternalTokenSet(input))}function readString(string){let point=/\\(?:u\{([\da-f]+)\}|u([\da-f]{4})|x([\da-f]{2})|([ntbrf0])|(.))|./yig,
out="",m;for(;m=point.exec(string);){let [all,u1,u2,u3,single,unknown]=m;out=u1||u2||u3?out+String.fromCodePoint(parseInt(u1||u2||u3,16)):single?out+("n"==single?"\n":"t"==single?"\t":"0"==single?"\x00":"r"==single?"\r":"f"==single?"\f":"\b"):unknown?out+unknown:out+all}return out}function hash$jscomp$0(a,b){return(a<<5)+a+b}function conflictsAt(group){let result=Conflicts.none;for(let pos of group)result=result.join(pos.conflicts());return result}function compareRepeatPrec(a,b){for(let pos of a)if(pos.rule.name.repeated)for(let posB of b)if(posB.rule.name==
pos.rule.name){if(pos.rule.isRepeatWrap&&2==pos.pos)return 1;if(posB.rule.isRepeatWrap&&2==posB.pos)return-1}return 0}function cmpStr(a,b){return a<b?-1:a>b?1:0}function termsAhead(rule,pos,after,first){let found=[];for(pos+=1;pos<rule.parts.length;pos++){let next=rule.parts[pos],cont=!1;if(next.terminal)addTo(next,found);else for(let term of first[next.name])null==term?cont=!0:addTo(term,found);if(!cont)return found}for(let a of after)addTo(a,found);return found}function eqSet(a,b){if(a.length!=
b.length)return!1;for(let i=0;i<a.length;i++)if(!a[i].eq(b[i]))return!1;return!0}function sameSet$1(a,b){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(a[i]!=b[i])return!1;return!0}function hashPositions(set){let h=5381;for(let pos of set)h=hash$jscomp$0(h,pos.hash);return h}function closure(set,first){function addFor(name,ahead,ambigAhead,skipAhead,via){for(let rule of name.rules){name=added.find(a=>a.rule==rule);name||(name=(name=set.find(p=>0==p.pos&&p.rule==rule))?new Pos(rule,0,
name.ahead.slice(),name.ambigAhead,name.skipAhead,name.via):new Pos(rule,0,[],none$2,skipAhead,via),added.push(name));if(name.skipAhead!=skipAhead)throw new GenError("Inconsistent skip sets after "+via.trail());name.ambigAhead=union(name.ambigAhead,ambigAhead);for(let term of ahead)name.ahead.includes(term)||(name.ahead.push(term),name.rule.parts.length&&!name.rule.parts[0].terminal&&addTo(name,redo))}}let added=[],redo=[];for(var pos of set){let next=pos.next;next&&!next.terminal&&addFor(next,termsAhead(pos.rule,
pos.pos,pos.ahead,first),pos.conflicts(pos.pos+1).ambigGroups,pos.pos==pos.rule.parts.length-1?pos.skipAhead:pos.rule.skip,pos)}for(;redo.length;)pos=redo.pop(),addFor(pos.rule.parts[0],termsAhead(pos.rule,0,pos.ahead,first),union(pos.rule.conflicts[1].ambigGroups,1==pos.rule.parts.length?pos.ambigAhead:none$2),pos.skipAhead,pos);first=set.slice();for(let add of added)add.ahead.sort((a,b)=>a.hash-b.hash),add.finish(),pos=set.findIndex(p=>0==p.pos&&p.rule==add.rule),-1<pos?first[pos]=add:first.push(add);
return first.sort((a,b)=>a.cmp(b))}function addTo(value,array){array.includes(value)||array.push(value)}function computeFirstSets(terms){let table=Object.create(null);for(var t$jscomp$0 of terms.terms)t$jscomp$0.terminal||(table[t$jscomp$0.name]=[]);for(;;){t$jscomp$0=!1;for(let nt of terms.terms)if(!nt.terminal)for(let rule of nt.rules){let set=table[nt.name],found=!1,startLen=set.length;for(let part of rule.parts){found=!0;if(part.terminal)addTo(part,set);else for(let t of table[part.name])null==
t?found=!1:addTo(t,set);if(found)break}found||addTo(null,set);set.length>startLen&&(t$jscomp$0=!0)}if(!t$jscomp$0)return table}}function findConflictOrigin(a,b){function via(root,start){let hist=[];for(let p=start.via;!p.eqSimple(root);p=p.via)hist.push(p);if(!hist.length)return"";hist.unshift(start);return hist.reverse().map((p,i)=>"\n"+"  ".repeat(i+1)+(p==start?"":"via ")+p).join("")}if(a.eqSimple(b))return"";for(let p=a;p;p=p.via)for(let p2=b;p2;p2=p2.via)if(p.eqSimple(p2))return"\nShared origin: "+
p+via(p,a)+via(p,b);return""}function buildFullAutomaton(terms,startTerms,first){function getState(core,top){if(0==core.length)return null;let coreHash=hashPositions(core);var byHash=cores[coreHash];let skip;for(var pos of core)if(!skip)skip=pos.skip;else if(skip!=pos.skip)throw new GenError("Inconsistent skip sets after "+pos.trail());if(byHash)for(let known of byHash)if(eqSet(core,known.set)){if(known.state.skip!=skip)throw new GenError("Inconsistent skip sets after "+known.set[0].trail());return known.state}byHash=
closure(core,first);pos=hashPositions(byHash);let found;if(!top)for(let state of states)state.hash==pos&&state.hasSet(byHash)&&(found=state);found||(found=new State$1(states.length,byHash,0,skip,pos,top),states.push(found),timing&&0==states.length%500&&console.log(`${states.length} states after ${((Date.now()-t0)/1E3).toFixed(2)}s`));(cores[coreHash]||(cores[coreHash]=[])).push(new Core(core,found));return found}let states=[],cores={},t0=Date.now();for(var startTerm of startTerms){const startSkip=
startTerm.rules.length?startTerm.rules[0].skip:terms.names["%noskip"];getState(startTerm.rules.map(rule=>(new Pos(rule,0,[terms.eof],none$2,startSkip,null)).finish()),startTerm)}startTerms=[];for(startTerm=0;startTerm<states.length;startTerm++){let state=states[startTerm];var byTerm=[];let byTermPos=[];var atEnd=[];for(let pos of state.set)if(pos.pos==pos.rule.parts.length)pos.rule.name.top||atEnd.push(pos);else{var next=pos.rule.parts[pos.pos],index=byTerm.indexOf(next);0>index?(byTerm.push(next),
byTermPos.push([pos])):byTermPos[index].push(pos)}for(next=0;next<byTerm.length;next++){index=byTerm[next];var positions=byTermPos[next].map(p=>p.advance());index.terminal?(positions=applyCut(positions),(positions=getState(positions))&&state.addAction(new Shift(index,positions),byTermPos[next],startTerms)):(positions=getState(positions))&&state.goto.push(new Shift(index,positions))}byTerm=!1;for(let pos of atEnd)for(let ahead of pos.ahead)atEnd=state.actions.length,state.addAction(new Reduce(ahead,
pos.rule),[pos],startTerms),state.actions.length==atEnd&&(byTerm=!0);if(byTerm)for(atEnd=0;atEnd<state.goto.length;atEnd++)first[state.goto[atEnd].term.name].some(term=>state.actions.some(a=>a.term==term&&a instanceof Shift))||state.goto.splice(atEnd--,1)}if(startTerms.length)throw new GenError(startTerms.map(c=>c.error).join("\n\n"));for(let state of states)state.finish();timing&&console.log(`${states.length} states total.`);return states}function applyCut(set){let found=null,cut=1;for(let pos of set){let value=
pos.rule.conflicts[pos.pos-1].cut;if(!(value<cut)){if(!found||value>cut)cut=value,found=[];found.push(pos)}}return found||set}function canMergeInner(a,b,mapping){for(let goto of a.goto)for(let other of b.goto)if(goto.term==other.term&&mapping[goto.target.id]!=mapping[other.target.id])return!1;a:for(let action of a.actions){a=!1;for(let other of b.actions)if(other.term==action.term){if(action instanceof Shift?other instanceof Shift&&mapping[action.target.id]==mapping[other.target.id]:other.eq(action))continue a;
a=!0}if(a)return!1}return!0}function canMerge(a,b,mapping){return canMergeInner(a,b,mapping)&&canMergeInner(b,a,mapping)}function mergeStates(states,mapping){let newStates=[];for(var state$jscomp$0 of states){let newID=mapping[state$jscomp$0.id];newStates[newID]||(newStates[newID]=new State$1(newID,state$jscomp$0.set,0,state$jscomp$0.skip,state$jscomp$0.hash,state$jscomp$0.startRule),newStates[newID].tokenGroup=state$jscomp$0.tokenGroup,newStates[newID].defaultReduce=state$jscomp$0.defaultReduce)}for(let state of states){states=
newStates[mapping[state.id]];states.flags|=state.flags;for(state$jscomp$0=0;state$jscomp$0<state.actions.length;state$jscomp$0++){let action=state.actions[state$jscomp$0].map(mapping,newStates);states.actions.some(a=>a.eq(action))||(states.actions.push(action),states.actionPositions.push(state.actionPositions[state$jscomp$0]))}for(let goto of state.goto){let mapped=goto.map(mapping,newStates);states.goto.some(g=>g.eq(mapped))||states.goto.push(mapped)}}return newStates}function samePosSet(a,b){if(a.length!=
b.length)return!1;for(let i=0;i<a.length;i++)if(!a[i].eqSimple(b[i]))return!1;return!0}function collapseAutomaton(states){function spill(groupIndex,index){let group=groups[groupIndex],state=states[group.members[index]],pop=group.members.pop();index!=group.members.length&&(group.members[index]=pop);for(groupIndex+=1;groupIndex<groups.length;groupIndex++)if(mapping[state.id]=groupIndex,groups[groupIndex].origin==group.origin&&groups[groupIndex].members.every(id=>canMerge(state,states[id],mapping))){groups[groupIndex].members.push(state.id);
return}mapping[state.id]=groups.length;groups.push(new Group(group.origin,state.id))}let mapping=[],groups=[];a:for(var i=0;i<states.length;i++){var state$jscomp$0=states[i];if(!state$jscomp$0.startRule)for(var j$jscomp$0=0;j$jscomp$0<groups.length;j$jscomp$0++){var group$jscomp$0=groups[j$jscomp$0],other=states[group$jscomp$0.members[0]];if(state$jscomp$0.tokenGroup==other.tokenGroup&&state$jscomp$0.skip==other.skip&&!other.startRule&&samePosSet(state$jscomp$0.set,other.set)){group$jscomp$0.members.push(i);
mapping.push(j$jscomp$0);continue a}}mapping.push(groups.length);groups.push(new Group(groups.length,i))}for(i=1;;i++){state$jscomp$0=!1;j$jscomp$0=Date.now();for(let g=0,startLen=groups.length;g<startLen;g++)for(group$jscomp$0=groups[g],other=0;other<group$jscomp$0.members.length-1;other++)for(let j=other+1;j<group$jscomp$0.members.length;j++)canMerge(states[group$jscomp$0.members[other]],states[group$jscomp$0.members[j]],mapping)||(state$jscomp$0=!0,spill(g,j--));timing&&console.log(`Collapse pass ${i}${state$jscomp$0?
"":", done"} (${((Date.now()-j$jscomp$0)/1E3).toFixed(2)}s)`);if(!state$jscomp$0)return mergeStates(states,mapping)}}function mergeIdentical(states){for(let pass=1;;pass++){let mapping=[],didMerge=!1,t0=Date.now(),newStates=[];for(let i=0;i<states.length;i++){let state=states[i];var match=newStates.findIndex(s=>state.eq(s));if(0>match)mapping[i]=newStates.length,newStates.push(state);else{mapping[i]=match;didMerge=!0;match=newStates[match];let add=null;for(let pos of state.set)match.set.some(p=>p.eqSimple(pos))||
(add||(add=[])).push(pos);add&&(match.set=add.concat(match.set).sort((a,b)=>a.cmp(b)))}}timing&&console.log(`Merge identical pass ${pass}${didMerge?"":", done"} (${((Date.now()-t0)/1E3).toFixed(2)}s)`);if(!didMerge)return states;for(let state of newStates)state.defaultReduce||(state.actions=state.actions.map(a=>a.map(mapping,newStates)),state.goto=state.goto.map(a=>a.map(mapping,newStates)));for(states=0;states<newStates.length;states++)newStates[states].id=states;states=newStates}}function encode(value,
max=65535){if(value>max)throw Error("Trying to encode a number that's too big: "+value);if(65535==value)return String.fromCharCode(126);max="";for(var first=46;;first=0){let low=value%46;value-=low;first=low+first+32;34<=first&&first++;92<=first&&first++;max=String.fromCharCode(first)+max;if(0==value)break;value/=46}return max}function encodeArray(values,max=65535){let result='"'+encode(values.length,4294967295);for(let i=0;i<values.length;i++)result+=encode(values[i],max);return result+'"'}function p$jscomp$0(...terms){return new Parts(terms,
null)}function addToProp(term,prop,value){let cur=term.props[prop];if(!cur||0>cur.split(" ").indexOf(value))term.props[prop]=cur?cur+" "+value:value}function buildSpecializeTable(spec){let table=Object.create(null);for(let {value,term,type}of spec)table[value]=term.id<<1|("specialize"==type?0:1);return table}function reduceAction(rule,skipInfo,depth=rule.parts.length){return rule.name.id|65536|(rule.isRepeatWrap&&depth==rule.parts.length?131072:0)|(skipInfo.some(i=>i.rule==rule.name)?262144:0)|depth<<
19}function findSkipStates(table,startRules){let nonSkip=Object.create(null),work=[],add=state=>{nonSkip[state.id]||(nonSkip[state.id]=!0,work.push(state))};for(let state of table)state.startRule&&startRules.includes(state.startRule)&&add(state);for(table=0;table<work.length;table++){for(let a of work[table].actions)a instanceof Shift&&add(a.target);for(let a of work[table].goto)add(a.target)}return id=>!nonSkip[id]}function computeGotoTable(states){let goto={},maxTerm=0;for(var state of states)for(var entry of state.goto)maxTerm=
Math.max(entry.term.id,maxTerm),states=goto[entry.term.id]||(goto[entry.term.id]={}),(states[entry.target.id]||(states[entry.target.id]=[])).push(state.id);state=new DataBuilder;entry=[];states=maxTerm+2;for(let term=0;term<=maxTerm;term++){let entries=goto[term];if(!entries){entry.push(1);continue}let termTable=[],keys=Object.keys(entries);for(let target of keys){let list=entries[target];termTable.push((target==keys[keys.length-1]?1:0)+(list.length<<1));termTable.push(+target);for(let source of list)termTable.push(source)}entry.push(state.storeArray(termTable)+
states)}if(entry.some(n=>65535<n))throw new GenError("Goto table too large");return Uint16Array.from([maxTerm+1,...entry,...state.data])}function addToSet(set,value){set.includes(value)||set.push(value)}function buildTokenMasks(groups){let masks=Object.create(null);for(let group of groups){groups=1<<group.id;for(let term of group.tokens)masks[term.id]=(masks[term.id]||0)|groups}return masks}function findExprAfter(ast,expr){function walk(cur){if(cur instanceof SequenceExpression){let index=cur.exprs.indexOf(expr);
-1<index&&index<cur.exprs.length-1&&(found=cur.exprs[index+1])}return cur}let found;for(let rule of ast.rules)rule.expr.walk(walk);for(let topRule of ast.topRules)topRule.expr.walk(walk);return found}function checkTogether(states,b$jscomp$0,skipInfo){function hasTerm(state,term){return state.actions.some(a=>a.term==term)||skipInfo[b$jscomp$0.skipRules.indexOf(state.skip)].startTokens.includes(term)}let cache=Object.create(null);return(a,b)=>{a.id<b.id&&([a,b]=[b,a]);let key=a.id|b.id<<16,cached=cache[key];
return null!=cached?cached:cache[key]=states.some(state=>hasTerm(state,a)&&hasTerm(state,b))}}function invertRanges(ranges){let pos=0,result=[];for(let [a,b]of ranges)a>pos&&result.push([pos,a]),pos=b;1114111>=pos&&result.push([pos,1114112]);return result}function rangeEdges(from,to,low,hi){if(55296>low&&1114112==hi)from.edge(low,65535,to);else if(65536>low&&(55296>low&&from.edge(low,Math.min(hi,55296),to),57344<hi&&from.edge(Math.max(low,57344),Math.min(hi,65535),to),low=65536),!(65536>hi)){low=
String.fromCodePoint(low);var hiStr=String.fromCodePoint(hi-1);hi=low.charCodeAt(0);low=low.charCodeAt(1);var hiA=hiStr.charCodeAt(0);hiStr=hiStr.charCodeAt(1);if(hi==hiA)hiA=new State,from.edge(hi,hi+1,hiA),hiA.edge(low,hiStr+1,to);else{let midStart=hi,midEnd=hiA;if(56320<low){midStart++;let hop=new State;from.edge(hi,hi+1,hop);hop.edge(low,57344,to)}57343>hiStr&&(midEnd--,hi=new State,from.edge(hiA,hiA+1,hi),hi.edge(56320,hiStr+1,to));midStart<=midEnd&&(hi=new State,from.edge(midStart,midEnd+1,
hi),hi.edge(56320,57344,to))}}}function isEmpty(expr){return expr instanceof SequenceExpression&&0==expr.exprs.length}function gatherExtTokens(b,tokens){let result=Object.create(null);for(let token of tokens){b.unique(token.id);let {name,props,dialect}=b.nodeInfo(token.props,"d",token.id.name);tokens=b.makeTerminal(token.id.name,name,props);null!=dialect&&(b.tokens.byDialect[dialect]||(b.tokens.byDialect[dialect]=[])).push(tokens);b.namedTerms[token.id.name]=result[token.id.name]=tokens}return result}
function findExtToken(b,tokens,expr){tokens=tokens[expr.id.name];if(!tokens)return null;expr.args.length&&b.raise("External tokens cannot take arguments",expr.args[0].start);b.used(expr.id.name);return tokens}function addRel(rel,term,after){let found=rel.findIndex(r=>r.term==term);0>found?rel.push({term,after}):rel[found]={term,after:rel[found].after.concat(after)}}function inlineRules(rules,preserve){for(let pass=0;;pass++){let inlinable=Object.create(null),found;if(0==pass)for(let rule of rules)if(rule.name.inline&&
!inlinable[rule.name.name]){let group=rules.filter(r=>r.name==rule.name);group.some(r=>r.parts.includes(rule.name))||(found=inlinable[rule.name.name]=group)}for(let i=0;i<rules.length;i++){let rule=rules[i];rule.name.interesting||rule.parts.includes(rule.name)||!(3>rule.parts.length)||preserve.includes(rule.name)||1!=rule.parts.length&&!rules.every(other=>other.skip==rule.skip||!other.parts.includes(rule.name))||rule.parts.some(p=>!!inlinable[p.name])||rules.some((r,j)=>j!=i&&r.name==rule.name)||
(found=inlinable[rule.name.name]=[rule])}if(!found)return rules;let newRules=[];for(let rule of rules)if(!inlinable[rule.name.name]){function expand(at,conflicts,parts){if(at==rule.parts.length)newRules.push(new Rule(rule.name,parts,conflicts,rule.skip));else{var next=rule.parts[at],replace=inlinable[next.name];if(replace)for(let r of replace)expand(at+1,conflicts.slice(0,conflicts.length-1).concat(conflicts[at].join(r.conflicts[0])).concat(r.conflicts.slice(1,r.conflicts.length-1)).concat(rule.conflicts[at+
1].join(r.conflicts[r.conflicts.length-1])),parts.concat(r.parts));else expand(at+1,conflicts.concat(rule.conflicts[at+1]),parts.concat(next))}}rule.parts.some(p=>!!inlinable[p.name])?expand(0,[rule.conflicts[0]],[]):newRules.push(rule)}rules=newRules}}function mergeRules(rules){let merged=Object.create(null);var found;for(let i=0;i<rules.length;){let groupStart=i,name=rules[i++].name;for(;i<rules.length&&rules[i].name==name;)i++;let size=i-groupStart;if(!name.interesting)for(let j=i;j<rules.length;){let otherStart=
j,otherName=rules[j++].name;for(;j<rules.length&&rules[j].name==otherName;)j++;if(j-otherStart!=size||otherName.interesting)continue;let match=!0;for(let k=0;k<size&&match;k++)0!=rules[groupStart+k].cmpNoName(rules[otherStart+k])&&(match=!1);match&&(found=merged[name.name]=otherName)}}if(!found)return rules;found=[];for(let rule of rules)merged[rule.name.name]||found.push(rule.parts.every(p=>!merged[p.name])?rule:new Rule(rule.name,rule.parts.map(p=>merged[p.name]||p),rule.conflicts,rule.skip));return found}
function simplifyRules(rules,preserve){return mergeRules(inlineRules(rules,preserve))}function isExported(rule){return rule.props.some(p=>p.at&&"export"==p.name)}var process=require("module$node_modules$process$browser");"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var lezer=require("module$node_modules$lezer$dist$index_cjs");class Node{constructor(start){this.start=start}}class GrammarDeclaration extends Node{constructor(start,rules,topRules,tokens,context,externalTokens,externalSpecializers,
precedences,mainSkip,scopedSkip,dialects,grammars,externalProps,autoDelim){super(start);this.rules=rules;this.topRules=topRules;this.tokens=tokens;this.context=context;this.externalTokens=externalTokens;this.externalSpecializers=externalSpecializers;this.precedences=precedences;this.mainSkip=mainSkip;this.scopedSkip=scopedSkip;this.dialects=dialects;this.grammars=grammars;this.externalProps=externalProps;this.autoDelim=autoDelim}toString(){return Object.values(this.rules).join("\n")}}class RuleDeclaration extends Node{constructor(start,
id,props,params,expr){super(start);this.id=id;this.props=props;this.params=params;this.expr=expr}toString(){return this.id.name+(this.params.length?`<${this.params.join()}>`:"")+" -\x3e "+this.expr}}class PrecDeclaration extends Node{constructor(start,items){super(start);this.items=items}}class TokenPrecDeclaration extends Node{constructor(start,items){super(start);this.items=items}}class TokenConflictDeclaration extends Node{constructor(start,a,b){super(start);this.a=a;this.b=b}}class TokenDeclaration extends Node{constructor(start,
precedences,conflicts,rules,literals){super(start);this.precedences=precedences;this.conflicts=conflicts;this.rules=rules;this.literals=literals}}class LiteralDeclaration extends Node{constructor(start,literal,props){super(start);this.literal=literal;this.props=props}}class ContextDeclaration extends Node{constructor(start,id,source){super(start);this.id=id;this.source=source}}class ExternalTokenDeclaration extends Node{constructor(start,id,source,tokens){super(start);this.id=id;this.source=source;
this.tokens=tokens}}class ExternalSpecializeDeclaration extends Node{constructor(start,type,token,id,source,tokens){super(start);this.type=type;this.token=token;this.id=id;this.source=source;this.tokens=tokens}}class ExternalGrammarDeclaration extends Node{constructor(start,id,externalID,source){super(start);this.id=id;this.externalID=externalID;this.source=source}}class ExternalPropDeclaration extends Node{constructor(start,id,externalID,source){super(start);this.id=id;this.externalID=externalID;
this.source=source}}class Identifier extends Node{constructor(start,name){super(start);this.name=name}toString(){return this.name}}class Expression extends Node{walk(f){return f(this)}eq(_other){return!1}}Expression.prototype.prec=10;class NameExpression extends Expression{constructor(start,namespace,id,args){super(start);this.namespace=namespace;this.id=id;this.args=args}toString(){return this.id.name+(this.args.length?`<${this.args.join()}>`:"")}eq(other){return(this.namespace?null!=other.namespace&&
other.namespace.name==this.namespace.name:!other.namespace)&&this.id.name==other.id.name&&exprsEq(this.args,other.args)}walk(f){let args=walkExprs(this.args,f);return f(args==this.args?this:new NameExpression(this.start,this.namespace,this.id,args))}}class SpecializeExpression extends Expression{constructor(start,type,props,token,content){super(start);this.type=type;this.props=props;this.token=token;this.content=content}toString(){return`@${this.type}[${this.props.join(",")}]<${this.token}, ${this.content}>`}eq(other){return this.type==
other.type&&Prop.eqProps(this.props,other.props)&&exprEq(this.token,other.token)&&exprEq(this.content,other.content)}walk(f){let token=this.token.walk(f),content=this.content.walk(f);return f(token==this.token&&content==this.content?this:new SpecializeExpression(this.start,this.type,this.props,token,content))}}class InlineRuleExpression extends Expression{constructor(start,rule){super(start);this.rule=rule}toString(){let rule=this.rule;return`${rule.id}${rule.props.length?`[${rule.props.join(",")}]`:
""} { ${rule.expr} }`}eq(other){let rule=this.rule;other=other.rule;return exprEq(rule.expr,other.expr)&&rule.id.name==other.id.name&&Prop.eqProps(rule.props,other.props)}walk(f){let rule=this.rule,expr=rule.expr.walk(f);return f(expr==rule.expr?this:new InlineRuleExpression(this.start,new RuleDeclaration(rule.start,rule.id,rule.props,[],expr)))}}class ChoiceExpression extends Expression{constructor(start,exprs){super(start);this.exprs=exprs}toString(){return this.exprs.map(e=>maybeParens(e,this)).join(" | ")}eq(other){return exprsEq(this.exprs,
other.exprs)}walk(f){let exprs=walkExprs(this.exprs,f);return f(exprs==this.exprs?this:new ChoiceExpression(this.start,exprs))}}ChoiceExpression.prototype.prec=1;class SequenceExpression extends Expression{constructor(start,exprs,markers){super(start);this.exprs=exprs;this.markers=markers}toString(){return this.exprs.map(e=>maybeParens(e,this)).join(" ")}eq(other){return exprsEq(this.exprs,other.exprs)&&this.markers.every((m,i$jscomp$0)=>{let om=other.markers[i$jscomp$0];return m.length==om.length&&
m.every((x,i)=>x.eq(om[i]))})}walk(f){let exprs=walkExprs(this.exprs,f);return f(exprs==this.exprs?this:new SequenceExpression(this.start,exprs,this.markers))}}SequenceExpression.prototype.prec=2;class ConflictMarker extends Node{constructor(start,id,type){super(start);this.id=id;this.type=type}toString(){return("ambig"==this.type?"~":"!")+this.id.name}eq(other){return this.id.name==other.id.name&&this.type==other.type}}class RepeatExpression extends Expression{constructor(start,expr,kind){super(start);
this.expr=expr;this.kind=kind}toString(){return maybeParens(this.expr,this)+this.kind}eq(other){return exprEq(this.expr,other.expr)&&this.kind==other.kind}walk(f){let expr=this.expr.walk(f);return f(expr==this.expr?this:new RepeatExpression(this.start,expr,this.kind))}}RepeatExpression.prototype.prec=3;class LiteralExpression extends Expression{constructor(start,value){super(start);this.value=value}toString(){return JSON.stringify(this.value)}eq(other){return this.value==other.value}}class SetExpression extends Expression{constructor(start,
ranges,inverted){super(start);this.ranges=ranges;this.inverted=inverted}toString(){return`[${this.inverted?"^":""}${this.ranges.map(([a,b])=>String.fromCodePoint(a)+(b==a+1?"":"-"+String.fromCodePoint(b)))}]`}eq(other){return this.inverted==other.inverted&&this.ranges.length==other.ranges.length&&this.ranges.every(([a,b],i)=>{let [x,y]=other.ranges[i];return a==x&&b==y})}}class AnyExpression extends Expression{constructor(start){super(start)}toString(){return"_"}eq(){return!0}}class Prop extends Node{constructor(start,
at,name,value){super(start);this.at=at;this.name=name;this.value=value}eq(other){return this.name==other.name&&this.value.length==other.value.length&&this.value.every((v,i)=>v.value==other.value[i].value&&v.name==other.value[i].name)}toString(){let result=(this.at?"@":"")+this.name;if(this.value.length){result+="\x3d";for(let {name,value}of this.value)result+=name?`{${name}}`:/[^\w-]/.test(value)?JSON.stringify(value):value}return result}static eqProps(a,b){return a.length==b.length&&a.every((p,i)=>
p.eq(b[i]))}}class PropPart extends Node{constructor(start,value,name){super(start);this.value=value;this.name=name}}class GenError extends Error{}let termHash=0;class Term{constructor(name,flags,nodeName,props={}){this.name=name;this.flags=flags;this.nodeName=nodeName;this.props=props;this.hash=++termHash;this.id=-1;this.rules=[]}toString(){return this.name}get nodeType(){return this.top||null!=this.nodeName||hasProps(this.props)||this.repeated}get terminal(){return 0<(this.flags&1)}get eof(){return 0<
(this.flags&4)}get error(){return"error"in this.props}get top(){return 0<(this.flags&2)}get interesting(){return 0<this.flags||null!=this.nodeName}get repeated(){return 0<(this.flags&16)}set preserve(value){this.flags=value?this.flags|8:this.flags&-9}get preserve(){return 0<(this.flags&8)}set inline(value){this.flags=value?this.flags|32:this.flags&-33}get inline(){return 0<(this.flags&32)}cmp(other){return this.hash-other.hash}}class TermSet{constructor(){this.terms=[];this.names=Object.create(null);
this.tops=[];this.eof=this.term("␄",null,5);this.error=this.term("⚠","⚠",8)}term(name,nodeName,flags=0,props={}){nodeName=new Term(name,flags,nodeName,props);this.terms.push(nodeName);return this.names[name]=nodeName}makeTop(nodeName,props){nodeName=this.term("@top",nodeName,2,props);this.tops.push(nodeName);return nodeName}makeTerminal(name,nodeName,props={}){return this.term(name,nodeName,1,props)}makeNonTerminal(name,nodeName,props={}){return this.term(name,nodeName,0,props)}makeRepeat(name){return this.term(name,
null,16)}uniqueName(name){for(let i=0;;i++){let cur=i?`${name}-${i}`:name;if(!this.names[cur])return cur}}finish(rules){for(var rule of rules)rule.name.rules.push(rule);this.terms=this.terms.filter(t=>t.terminal||t.preserve||rules.some(r=>r.name==t||r.parts.includes(t)));rule={};let nodeTypes=[this.error];this.error.id=0;let nextID=1;for(var term$jscomp$0 of this.terms)0>term$jscomp$0.id&&term$jscomp$0.nodeType&&!term$jscomp$0.repeated&&(term$jscomp$0.id=nextID++,nodeTypes.push(term$jscomp$0));term$jscomp$0=
nextID;for(let term of this.terms)term.repeated&&(term.id=nextID++,nodeTypes.push(term));this.eof.id=nextID++;for(let term of this.terms)0>term.id&&(term.id=nextID++),term.name&&(rule[term.id]=term.name);if(65534<=nextID)throw new GenError("Too many terms");return{nodeTypes,names:rule,minRepeatTerm:term$jscomp$0,maxTerm:nextID-1}}}const none=[];class Conflicts{constructor(precedence,ambigGroups=none,cut=0){this.precedence=precedence;this.ambigGroups=ambigGroups;this.cut=cut}join(other){return this==
Conflicts.none||this==other?other:other==Conflicts.none?this:new Conflicts(Math.max(this.precedence,other.precedence),union(this.ambigGroups,other.ambigGroups),Math.max(this.cut,other.cut))}cmp(other){return this.precedence-other.precedence||cmpSet(this.ambigGroups,other.ambigGroups,(a,b)=>a<b?-1:a>b?1:0)||this.cut-other.cut}}Conflicts.none=new Conflicts(0);let ruleID=0;class Rule{constructor(name,parts,conflicts,skip){this.name=name;this.parts=parts;this.conflicts=conflicts;this.skip=skip;this.id=
ruleID++}cmp(rule){return this.id-rule.id}cmpNoName(rule){return this.parts.length-rule.parts.length||this.skip.hash-rule.skip.hash||this.parts.reduce((r,s,i)=>r||s.cmp(rule.parts[i]),0)||cmpSet(this.conflicts,rule.conflicts,(a,b)=>a.cmp(b))}toString(){return this.name+" -\x3e "+this.parts.join(" ")}get isRepeatWrap(){return this.name.repeated&&2==this.parts.length&&this.parts[0]==this.name}sameReduce(other){return this.name==other.name&&this.parts.length==other.parts.length&&this.isRepeatWrap==other.isRepeatWrap}}
class Edge{constructor(from,to,target){this.from=from;this.to=to;this.target=target}toString(){return`-> ${this.target.id}[label=${JSON.stringify(0>this.from?"ε":charFor(this.from)+(this.to>this.from+1?"-"+charFor(this.to-1):""))}]`}}let stateID=1;class State{constructor(accepting=[],id=stateID++){this.accepting=accepting;this.id=id;this.edges=[]}edge(from,to,target){this.edges.push(new Edge(from,to,target))}nullEdge(target){this.edge(-1,-1,target)}compile(){function explore(states){let newState=
labeled[ids(states)]=new State(states.reduce((a,s)=>union(a,s.accepting),[]),localID++),out=[];for(let state of states)for(let edge of state.edges)0<=edge.from&&out.push(edge);states=mergeEdges(out);for(let merged of states)states=merged.targets.sort((a,b)=>a.id-b.id),newState.edge(merged.from,merged.to,labeled[ids(states)]||explore(states));return newState}let labeled=Object.create(null),localID=0,startState=explore(this.closure().sort((a,b)=>a.id-b.id));return minimize(Object.values(labeled),startState)}closure(){function explore(state){if(!result.includes(state)){(state.edges.some(e=>
0<=e.from)||0<state.accepting.length&&!state.edges.some(e=>{a:{var JSCompiler_inline_result=state.accepting;e=e.target.accepting;if(JSCompiler_inline_result.length!=e.length)JSCompiler_inline_result=!1;else{for(let i=0;i<JSCompiler_inline_result.length;i++)if(JSCompiler_inline_result[i]!=e[i]){JSCompiler_inline_result=!1;break a}JSCompiler_inline_result=!0}}return JSCompiler_inline_result}))&&result.push(state);for(let edge of state.edges)0>edge.from&&explore(edge.target)}}let result=[];explore(this);
return result}findConflicts(occurTogether){function add(a,b,soft,aEdges,bEdges){a.id<b.id&&([a,b]=[b,a],soft=-soft);let found=conflicts.find(c=>c.a==a&&c.b==b);found?found.soft!=soft&&(found.soft=0):conflicts.push(new Conflict(a,b,soft,exampleFromEdges(aEdges),bEdges&&exampleFromEdges(bEdges)))}let conflicts=[],cycleTerms=this.cycleTerms();this.reachable((state,edges)=>{if(0!=state.accepting.length){for(let i=0;i<state.accepting.length;i++)for(let j=i+1;j<state.accepting.length;j++)add(state.accepting[i],
state.accepting[j],0,edges);state.reachable((s,es)=>{if(s!=state)for(let term of s.accepting){s=cycleTerms.includes(term);for(let orig of state.accepting)term!=orig&&add(term,orig,s||cycleTerms.includes(orig)||!occurTogether(term,orig)?0:1,edges,edges.concat(es))}})}});return conflicts}cycleTerms(){let work=[];this.reachable(state=>{for(let {target}of state.edges)work.push(state,target)});var table=new Map;let haveCycle=[];for(let i=0;i<work.length;){let from=work[i++],to=work[i++],entry=table.get(from);
entry||table.set(from,entry=[]);if(!entry.includes(to))if(from==to)haveCycle.includes(from)||haveCycle.push(from);else{for(let next of entry)work.push(from,next);entry.push(to)}}table=[];for(let state of haveCycle)for(let term of state.accepting)table.includes(term)||table.push(term);return table}reachable(f){let seen=[],edges=[];(function explore(s){f(s,edges);seen.push(s);for(let edge of s.edges)seen.includes(edge.target)||(edges.push(edge),explore(edge.target),edges.pop())})(this)}toString(){let out=
"digraph {\n";this.reachable(state=>{state.accepting.length&&(out+=`  ${state.id} [label=${JSON.stringify(state.accepting.join())}];\n`);for(let edge of state.edges)out+=`  ${state.id} ${edge};\n`});return out+"}"}toArray(groupMasks,precedence){let offsets=[],data=[];this.reachable(state=>{let start=data.length,acceptEnd=start+3+2*state.accepting.length;offsets[state.id]=start;data.push(state.stateMask(groupMasks),acceptEnd,state.edges.length);state.accepting.sort((a,b)=>precedence.indexOf(a.id)-
precedence.indexOf(b.id));for(let term of state.accepting)data.push(term.id,groupMasks[term.id]||65535);for(let edge of state.edges)data.push(edge.from,edge.to,-edge.target.id-1)});for(let i=0;i<data.length;i++)0>data[i]&&(data[i]=offsets[-data[i]-1]);if(65536<data.length)throw new GenError("Tokenizer tables too big to represent with 16-bit offsets.");return Uint16Array.from(data)}stateMask(groupMasks){let mask=0;this.reachable(state=>{for(let term of state.accepting)mask|=groupMasks[term.id]||65535});
return mask}}class Conflict{constructor(a,b,soft,exampleA,exampleB){this.a=a;this.b=b;this.soft=soft;this.exampleA=exampleA;this.exampleB=exampleB}}class MergedEdge{constructor(from,to,targets){this.from=from;this.to=to;this.targets=targets}}let word=/[\w_-]+/gy;try{word=/[\p{Alphabetic}\d_-]+/ugy}catch(_){}const none$1=[];class Input{constructor(string,fileName=null){this.string=string;this.fileName=fileName;this.type="sof";this.value=null;this.end=this.start=0;this.next()}lineInfo(pos){for(let line=
1,cur=0;;){let next=this.string.indexOf("\n",cur);if(-1<next&&next<pos)++line,cur=next+1;else return{line,ch:pos-cur}}}message(msg,pos=-1){let posInfo=this.fileName||"";-1<pos&&(pos=this.lineInfo(pos),posInfo+=(posInfo?" ":"")+pos.line+":"+pos.ch);return posInfo?msg+` (${posInfo})`:msg}raise(msg,pos=-1){throw new GenError(this.message(msg,pos));}match(pos,re){return(re=re.exec(this.string.slice(pos)))?pos+re[0].length:-1}next(){let start=this.match(this.end,/^(\s|\/\/.*|\/\*[^]*?\*\/)*/);if(start==
this.string.length)return this.set("eof",null,start,start);var next=this.string[start];if('"'==next)return next=this.match(start+1,/^(\\.|[^"])*"/),-1==next&&this.raise("Unterminated string literal",start),this.set("string",readString(this.string.slice(start+1,next-1)),start,next);if("'"==next)return next=this.match(start+1,/^(\\.|[^'])*'/),-1==next&&this.raise("Unterminated string literal",start),this.set("string",readString(this.string.slice(start+1,next-1)),start,next);if("@"==next)return word.lastIndex=
start+1,(next=word.exec(this.string))?this.set("at",next[0],start,start+1+next[0].length):this.raise("@ without a name",start);if("$"!=next&&"!"!=next||"["!=this.string[start+1]){if(/[\[\]()!~+*?{}<>\.,|:$=]/.test(next))return this.set(next,null,start,start+1);word.lastIndex=start;let m=word.exec(this.string);return m?this.set("id",m[0],start,start+m[0].length):this.raise("Unexpected character "+JSON.stringify(next),start)}next=this.match(start+2,/^(?:\\.|[^\]])*\]/);-1==next&&this.raise("Unterminated character set",
start);return this.set("set",this.string.slice(start+2,next-1),start,next)}set(type,value,start,end){this.type=type;this.value=value;this.start=start;this.end=end}eat(type,value=null){if(this.type!=type||null!=value&&this.value!==value)return!1;this.next();return!0}unexpected(){return this.raise(`Unexpected token '${this.string.slice(this.start,this.end)}'`,this.start)}expect(type,value=null){let val=this.value;(this.type!=type||null!=value&&val!==value)&&this.unexpected();this.next();return val}parse(){{var JSCompiler_inline_result=
this.start;let rules=[];var prec=null,tokens=null;let mainSkip=null,scopedSkip=[],dialects=[];var context=null;let external=[],specialized=[],nested=[],props=[],tops=[],autoDelim=!1;for(;"eof"!=this.type;){var start=this.start;if("at"==this.type&&"top"==this.value)this.next(),"id"!=this.type&&this.raise("Top rules must have a name",this.start),start=parseIdent(this),tops.length&&"@top"===start.name&&this.raise("Unnamed secondary @top declaration",this.start),tops.push(parseRule(this,start));else if("at"==
this.type&&"tokens"==this.value)if(tokens)this.raise("Multiple @tokens declaractions",this.start);else{tokens=this.start;this.next();this.expect("{");start=[];for(var literals=[],precedences=[],conflicts=[];!this.eat("}");)if("at"==this.type&&"precedence"==this.value){var JSCompiler_temp_const=precedences,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.push;var JSCompiler_inline_result$jscomp$0=this.start;this.next();this.expect("{");for(var tokens$jscomp$0=[];!this.eat("}");){tokens$jscomp$0.length&&
this.eat(",");var expr=parseExprInner(this);expr instanceof LiteralExpression||expr instanceof NameExpression?tokens$jscomp$0.push(expr):this.raise("Invalid expression in token precedences",expr.start)}JSCompiler_inline_result$jscomp$0=new TokenPrecDeclaration(JSCompiler_inline_result$jscomp$0,tokens$jscomp$0);JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,JSCompiler_inline_result$jscomp$0)}else"at"==this.type&&"conflict"==this.value?(JSCompiler_temp_const=conflicts,JSCompiler_temp_const$jscomp$0=
JSCompiler_temp_const.push,JSCompiler_inline_result$jscomp$0=this.start,this.next(),this.expect("{"),tokens$jscomp$0=parseExprInner(this),tokens$jscomp$0 instanceof LiteralExpression||tokens$jscomp$0 instanceof NameExpression||this.raise("Invalid expression in token conflict",tokens$jscomp$0.start),this.eat(","),expr=parseExprInner(this),expr instanceof LiteralExpression||expr instanceof NameExpression||this.raise("Invalid expression in token conflict",expr.start),this.expect("}"),JSCompiler_inline_result$jscomp$0=
new TokenConflictDeclaration(JSCompiler_inline_result$jscomp$0,tokens$jscomp$0,expr),JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,JSCompiler_inline_result$jscomp$0)):"string"==this.type?literals.push(new LiteralDeclaration(this.start,this.expect("string"),parseProps(this))):start.push(parseRule(this));tokens=new TokenDeclaration(tokens,precedences,conflicts,start,literals)}else if(this.eat("at","context"))context&&this.raise("Multiple @context declarations",start),context=parseIdent(this),
this.expect("id","from"),literals=this.expect("string"),context=new ContextDeclaration(start,context,literals);else if(this.eat("at","external"))this.eat("id","tokens")?(literals=external,precedences=literals.push,conflicts=parseIdent(this),this.expect("id","from"),JSCompiler_temp_const=this.expect("string"),start=new ExternalTokenDeclaration(start,conflicts,JSCompiler_temp_const,parseExternalTokenSet(this)),precedences.call(literals,start)):this.eat("id","grammar")?(literals=nested,precedences=literals.push,
conflicts=parseIdent(this),JSCompiler_temp_const=this.eat("id","as")?parseIdent(this):conflicts,JSCompiler_temp_const$jscomp$0=null,this.eat("id","from")?JSCompiler_temp_const$jscomp$0=this.expect("string"):this.expect("id","empty"),start=new ExternalGrammarDeclaration(start,JSCompiler_temp_const,conflicts,JSCompiler_temp_const$jscomp$0),precedences.call(literals,start)):this.eat("id","prop")?(literals=props,precedences=literals.push,conflicts=parseIdent(this),JSCompiler_temp_const=this.eat("id",
"as")?parseIdent(this):conflicts,this.expect("id","from"),JSCompiler_temp_const$jscomp$0=this.expect("string"),start=new ExternalPropDeclaration(start,JSCompiler_temp_const,conflicts,JSCompiler_temp_const$jscomp$0),precedences.call(literals,start)):this.eat("id","extend")?specialized.push(parseExternalSpecialize(this,"extend",start)):this.eat("id","specialize")?specialized.push(parseExternalSpecialize(this,"specialize",start)):this.unexpected();else if(this.eat("at","dialects"))for(this.expect("{"),
start=!0;!this.eat("}");start=!1)start||this.eat(","),dialects.push(parseIdent(this));else if("at"==this.type&&"precedence"==this.value){prec&&this.raise("Multiple precedence declarations",this.start);prec=this.start;this.next();this.expect("{");for(start=[];!this.eat("}");)start.length&&this.eat(","),start.push({id:parseIdent(this),type:this.eat("at","left")?"left":this.eat("at","right")?"right":this.eat("at","cut")?"cut":null});prec=new PrecDeclaration(prec,start)}else if(this.eat("at","detectDelim"))autoDelim=
!0;else if(this.eat("at","skip"))if(start=parseBracedExpr(this),"{"==this.type){this.next();for(literals=[];!this.eat("}");)literals.push(parseRule(this));scopedSkip.push({expr:start,rules:literals})}else mainSkip&&this.raise("Multiple top-level skip declarations",this.start),mainSkip=start;else rules.push(parseRule(this))}JSCompiler_inline_result=tops.length?new GrammarDeclaration(JSCompiler_inline_result,rules,tops,tokens,context,external,specialized,prec,mainSkip,scopedSkip,dialects,nested,props,
autoDelim):this.raise("Missing @top declaration")}return JSCompiler_inline_result}}const verbose="undefined"!=typeof process&&process.env.LOG||"",timing=/\btime\b/.test(verbose),time=timing?(label,f)=>{let t0=Date.now();f=f();console.log(`${label} (${((Date.now()-t0)/1E3).toFixed(2)}s)`);return f}:(_label,f)=>f();class Pos{constructor(rule,pos,ahead,ambigAhead,skipAhead,via){this.rule=rule;this.pos=pos;this.ahead=ahead;this.ambigAhead=ambigAhead;this.skipAhead=skipAhead;this.via=via;this.hash=0}finish(){var h=
hash$jscomp$0(hash$jscomp$0(this.rule.id,this.pos),this.skipAhead.hash);for(var a of this.ahead)h=hash$jscomp$0(h,a.hash);for(let group of this.ambigAhead){a=group;for(let i=0;i<a.length;i++)h=hash$jscomp$0(h,a.charCodeAt(i))}this.hash=h;return this}get next(){return this.pos<this.rule.parts.length?this.rule.parts[this.pos]:null}advance(){return(new Pos(this.rule,this.pos+1,this.ahead,this.ambigAhead,this.skipAhead,this.via)).finish()}get skip(){return this.pos==this.rule.parts.length?this.skipAhead:
this.rule.skip}cmp(pos){return this.rule.cmp(pos.rule)||this.pos-pos.pos||this.skipAhead.hash-pos.skipAhead.hash||cmpSet(this.ahead,pos.ahead,(a,b)=>a.cmp(b))||cmpSet(this.ambigAhead,pos.ambigAhead,cmpStr)}eqSimple(pos){return pos.rule==this.rule&&pos.pos==this.pos}toString(){let parts=this.rule.parts.map(t=>t.name);parts.splice(this.pos,0,"·");return`${this.rule.name} -> ${parts.join(" ")}`}eq(other){return this==other||this.hash==other.hash&&this.rule==other.rule&&this.pos==other.pos&&this.skipAhead==
other.skipAhead&&sameSet$1(this.ahead,other.ahead)&&sameSet$1(this.ambigAhead,other.ambigAhead)}trail(maxLen=60){var result=[];for(let pos=this;pos;pos=pos.via)for(let i=pos.pos-1;0<=i;i--)result.push(pos.rule.parts[i]);result=result.reverse().join(" ");result.length>maxLen&&(result=result.slice(result.length-maxLen).replace(/.*? /,"… "));return result}conflicts(pos=this.pos){let result=this.rule.conflicts[pos];pos==this.rule.parts.length&&this.ambigAhead.length&&(result=result.join(new Conflicts(0,
this.ambigAhead)));return result}static addOrigins(group,context){group=group.slice();for(let i=0;i<group.length;i++){let next=group[i];if(0==next.pos)for(let pos of context)pos.next!=next.rule.name||group.includes(pos)||group.push(pos)}return group}}class Shift{constructor(term,target){this.term=term;this.target=target}eq(other){return other instanceof Shift&&this.term==other.term&&other.target.id==this.target.id}cmp(other){return other instanceof Reduce?-1:this.term.id-other.term.id||this.target.id-
other.target.id}toString(){return"s"+this.target.id}map(mapping,states){mapping=states[mapping[this.target.id]];return mapping==this.target?this:new Shift(this.term,mapping)}}class Reduce{constructor(term,rule){this.term=term;this.rule=rule}eq(other){return other instanceof Reduce&&this.term==other.term&&other.rule.sameReduce(this.rule)}cmp(other){return other instanceof Shift?1:this.term.id-other.term.id||this.rule.name.id-other.rule.name.id||this.rule.parts.length-other.rule.parts.length}toString(){return`${this.rule.name.name}(${this.rule.parts.length})`}map(){return this}}
class State$1{constructor(id,set,flags=0,skip,hash=hashPositions(set),startRule=null){this.id=id;this.set=set;this.flags=flags;this.skip=skip;this.hash=hash;this.startRule=startRule;this.actions=[];this.actionPositions=[];this.goto=[];this.tokenGroup=-1;this.defaultReduce=null;this.nested=-1}toString(){let actions=this.actions.map(t=>t.term+"\x3d"+t).join(",")+(this.goto.length?" | "+this.goto.map(g=>g.term+"\x3d"+g).join(","):"");return this.id+": "+this.set.filter(p=>0<p.pos).join()+(this.defaultReduce?
`\n  always ${this.defaultReduce.name}(${this.defaultReduce.parts.length})`:actions.length?"\n  "+actions:"")}addActionInner(value,positions){for(let i=0;i<this.actions.length;i++){let action=this.actions[i];if(action.term==value.term){if(action.eq(value))return null;var fullPos=Pos.addOrigins(positions,this.set);let actionFullPos=Pos.addOrigins(this.actionPositions[i],this.set),conflicts=conflictsAt(fullPos),actionConflicts=conflictsAt(actionFullPos);fullPos=compareRepeatPrec(fullPos,actionFullPos)||
conflicts.precedence-actionConflicts.precedence;if(0<fullPos)this.actions.splice(i,1),this.actionPositions.splice(i,1),i--;else{if(0>fullPos)return null;if(!conflicts.ambigGroups.some(g=>actionConflicts.ambigGroups.includes(g)))return action}}}this.actions.push(value);this.actionPositions.push(positions);return null}addAction(value,positions,conflicts){var conflict=this.addActionInner(value,positions);if(conflict){let conflictPos=this.actionPositions[this.actions.indexOf(conflict)][0],rules=[positions[0].rule.name,
conflictPos.rule.name];conflicts.some(c=>c.rules.some(r=>rules.includes(r)))||(conflict=conflict instanceof Shift?`shift/reduce conflict between\n  ${conflictPos}\nand\n  ${positions[0].rule}`:`reduce/reduce conflict between\n  ${conflictPos.rule}\nand\n  ${positions[0].rule}`,conflict+=`\nWith input:\n  ${positions[0].trail(70)} · ${value.term} …`,conflict+=findConflictOrigin(conflictPos,positions[0]),conflicts.push(new Conflict$1(conflict,rules)))}}getGoto(term){return this.goto.find(a=>a.term==
term)}hasSet(set){return eqSet(this.set,set)}finish(){if(this.actions.length){let first=this.actions[0];if(first instanceof Reduce){let {rule}=first;this.actions.every(a=>a instanceof Reduce&&a.rule.sameReduce(rule))&&(this.defaultReduce=rule)}}this.actions.sort((a,b)=>a.cmp(b));this.goto.sort((a,b)=>a.cmp(b))}eq(other){let dThis=this.defaultReduce,dOther=other.defaultReduce;return dThis||dOther?dThis&&dOther?dThis.sameReduce(dOther):!1:this.skip==other.skip&&this.tokenGroup==other.tokenGroup&&eqSet(this.actions,
other.actions)&&eqSet(this.goto,other.goto)}}class Core{constructor(set,state){this.set=set;this.state=state}}class Conflict$1{constructor(error,rules){this.error=error;this.rules=rules}}class Group{constructor(origin,member){this.origin=origin;this.members=[member]}}const none$2=[],none$3=[];class Parts{constructor(terms,conflicts){this.terms=terms;this.conflicts=conflicts}concat(other){if(this==Parts.none)return other;if(other==Parts.none)return this;let conflicts=null;if(this.conflicts||other.conflicts){conflicts=
this.conflicts?this.conflicts.slice():this.ensureConflicts();let otherConflicts=other.ensureConflicts();conflicts[conflicts.length-1]=conflicts[conflicts.length-1].join(otherConflicts[0]);for(let i=1;i<otherConflicts.length;i++)conflicts.push(otherConflicts[i])}return new Parts(this.terms.concat(other.terms),conflicts)}withConflicts(pos,conflicts){if(conflicts==Conflicts.none)return this;let array=this.conflicts?this.conflicts.slice():this.ensureConflicts();array[pos]=array[pos].join(conflicts);return new Parts(this.terms,
array)}ensureConflicts(){if(this.conflicts)return this.conflicts;let empty=[];for(let i=0;i<=this.terms.length;i++)empty.push(Conflicts.none);return empty}}Parts.none=new Parts(none$3,null);class BuiltRule{constructor(id,args,term){this.id=id;this.args=args;this.term=term}matches(expr){return this.id==expr.id.name&&exprsEq(expr.args,this.args)}matchesRepeat(expr){return"+"==this.id&&exprEq(expr.expr,this.args[0])}}class Builder{constructor(text,options){this.options=options;this.terms=new TermSet;
this.nestedParsers=[];this.specialized=Object.create(null);this.tokenOrigins=Object.create(null);this.rules=[];this.built=[];this.ruleNames=Object.create(null);this.namespaces=Object.create(null);this.namedTerms=Object.create(null);this.termTable=Object.create(null);this.knownProps=Object.create(null);this.dynamicRulePrecedences=[];this.definedGroups=[];this.astRules=[];this.currentSkip=[];time("Parse",()=>{this.input=new Input(text,options.fileName);this.ast=this.input.parse()});var NP=lezer.NodeProp;
for(let prop in NP)NP[prop]instanceof lezer.NodeProp&&(this.knownProps[prop]={prop:NP[prop],source:{name:prop,from:null}});for(let prop of this.ast.externalProps)this.knownProps[prop.id.name]={prop:this.options.externalProp?this.options.externalProp(prop.id.name):lezer.NodeProp.string(),source:{name:prop.externalID.name,from:prop.source}};this.dialects=this.ast.dialects.map(d=>d.name);this.tokens=new TokenSet(this,this.ast.tokens);this.externalTokens=this.ast.externalTokens.map(ext=>new ExternalTokenSet(this,
ext));this.externalSpecializers=this.ast.externalSpecializers.map(decl=>new ExternalSpecializer(this,decl));this.defineNamespace("nest",new NestNamespace);for(let grammar of this.ast.grammars)this.ast.grammars.some(g=>g!=grammar&&g.id.name==grammar.id.name)&&this.raise(`Duplicate external grammar name '${grammar.id.name}'`,grammar.id.start);time("Build rules",()=>{var noSkip=this.newName("%noskip",!0);this.defineRule(noSkip,[]);let mainSkip=this.ast.mainSkip?this.newName("%mainskip",!0):noSkip,scopedSkip=
[];for(var rule$jscomp$0 of this.ast.rules)this.astRules.push({skip:mainSkip,rule:rule$jscomp$0});for(let scoped of this.ast.scopedSkip){rule$jscomp$0=noSkip;let found=this.ast.scopedSkip.findIndex((sc,i)=>i<scopedSkip.length&&exprEq(sc.expr,scoped.expr));-1<found?rule$jscomp$0=scopedSkip[found]:this.ast.mainSkip&&exprEq(scoped.expr,this.ast.mainSkip)?rule$jscomp$0=mainSkip:isEmpty(scoped.expr)||(rule$jscomp$0=this.newName("%skip",!0));scopedSkip.push(rule$jscomp$0);for(var rule$jscomp$1 of scoped.rules)this.astRules.push({skip:rule$jscomp$0,
rule:rule$jscomp$1})}for(var {rule:rule$jscomp$2}of this.astRules)this.unique(rule$jscomp$2.id),this.namespaces[rule$jscomp$2.id.name]&&this.raise(`Rule name '${rule$jscomp$2.id.name}' conflicts with a defined namespace`,rule$jscomp$2.id.start);this.currentSkip.push(noSkip);this.skipRules=mainSkip==noSkip?[mainSkip]:[noSkip,mainSkip];mainSkip!=noSkip&&this.defineRule(mainSkip,this.normalizeExpr(this.ast.mainSkip));for(rule$jscomp$1=0;rule$jscomp$1<this.ast.scopedSkip.length;rule$jscomp$1++)rule$jscomp$2=
scopedSkip[rule$jscomp$1],this.skipRules.includes(rule$jscomp$2)||(this.skipRules.push(rule$jscomp$2),rule$jscomp$2!=noSkip&&this.defineRule(rule$jscomp$2,this.normalizeExpr(this.ast.scopedSkip[rule$jscomp$1].expr)));this.currentSkip.pop();for(const top of this.ast.topRules){this.unique(top.id);this.used(top.id.name);this.currentSkip.push(mainSkip);let {name,props}=this.nodeInfo(top.props,"t",top.id.name,none$3,none$3,top.expr);noSkip=this.terms.makeTop(name,props);this.namedTerms[name]=noSkip;this.defineRule(noSkip,
this.normalizeExpr(top.expr));this.currentSkip.pop()}for(let ext of this.externalSpecializers)ext.finish();for(let {skip,rule}of this.astRules)this.ruleNames[rule.id.name]&&isExported(rule)&&!rule.params.length&&(this.buildRule(rule,[],skip,!1),rule.expr instanceof SequenceExpression&&0==rule.expr.exprs.length&&this.used(rule.id.name))});for(let name in this.ruleNames)(NP=this.ruleNames[name])&&this.warn(`Unused rule '${NP.name}'`,NP.start);this.tokens.takePrecedences();this.tokens.takeConflicts();
for(let {name,group,rule}of this.definedGroups)this.defineGroup(name,group,rule);this.checkGroups()}unique(id){id.name in this.ruleNames&&this.raise(`Duplicate definition of rule '${id.name}'`,id.start);this.ruleNames[id.name]=id}used(name){this.ruleNames[name]=null}defineNamespace(name,value,pos=0){this.namespaces[name]&&this.raise(`Duplicate definition of namespace '${name}'`,pos);this.namespaces[name]=value}newName(base,nodeName=null,props={}){for(let i=nodeName?0:1;;i++){let name=i?`${base}-${i}`:
base;if(!this.terms.names[name])return this.terms.makeNonTerminal(name,!0===nodeName?null:nodeName,props)}}prepareParser(){var rules$jscomp$0=time("Simplify rules",()=>simplifyRules(this.rules,[...this.skipRules,...this.nestedParsers.map(g=>g.placeholder),...this.terms.tops]));let {nodeTypes,names:termNames,minRepeatTerm,maxTerm}=this.terms.finish(rules$jscomp$0);for(var prop in this.namedTerms)this.termTable[prop]=this.namedTerms[prop].id;/\bgrammar\b/.test(verbose)&&console.log(rules$jscomp$0.join("\n"));
let startTerms=this.terms.tops.slice(),first=computeFirstSets(this.terms),skipInfo=this.skipRules.map((name,id)=>{let skip=[],startTokens=[],rules=[];for(let rule of name.rules){if(!rule.parts.length)continue;let start=rule.parts[0];for(let t of start.terminal?[start]:first[start.name]||[])startTokens.includes(t)||startTokens.push(t);start.terminal&&1==rule.parts.length&&!rules.some(r=>r!=rule&&r.parts[0]==start)?skip.push(start):rules.push(rule)}name.rules=rules;rules.length&&startTerms.push(name);
return{skip,rule:rules.length?name:null,startTokens,id}}),fullTable=time("Build full automaton",()=>buildFullAutomaton(this.terms,startTerms,first)),{tokenGroups,tokenPrec,tokenData}=time("Build token groups",()=>this.tokens.buildTokenGroups(fullTable,skipInfo)),table=time("Finish automaton",()=>mergeIdentical(collapseAutomaton(fullTable))),skipState=findSkipStates(table,this.terms.tops);this.addNestedParsers(table);/\blr\b/.test(verbose)&&console.log(table.join("\n"));rules$jscomp$0=[];for(var ext of this.externalSpecializers)rules$jscomp$0.push(ext);
for(var name$jscomp$0 in this.specialized)rules$jscomp$0.push({token:this.terms.names[name$jscomp$0],table:buildSpecializeTable(this.specialized[name$jscomp$0])});let tokStart=tokenizer=>tokenizer instanceof ExternalTokenDeclaration?tokenizer.start:this.tokens.ast?this.tokens.ast.start:-1,tokenizers=tokenGroups.concat(this.externalTokens.map(e=>e.ast)).sort((a,b)=>tokStart(a)-tokStart(b)),data=new DataBuilder,skipData=skipInfo.map(info=>{let actions=[];for(var term of info.skip)actions.push(term.id,
0,4);if(info.rule){term=table.find(s=>s.startRule==info.rule);for(let action of term.actions)actions.push(action.term.id,term.id,2)}actions.push(65535,0);return data.storeArray(actions)});ext=time("Finish states",()=>{let states=new Uint32Array(6*table.length),forceReductions=this.computeForceReductions(table,skipInfo),finishCx=new FinishStateContext(tokenizers,data,states,skipData,skipInfo,table,this);for(let s of table)finishCx.finish(s,skipState(s.id),forceReductions[s.id]);return states});name$jscomp$0=
Object.create(null);for(prop=0;prop<this.dialects.length;prop++)name$jscomp$0[this.dialects[prop]]=data.storeArray((this.tokens.byDialect[prop]||none$3).map(t=>t.id).concat(65535));prop=null;if(this.dynamicRulePrecedences.length){prop=Object.create(null);for(let {rule,prec}of this.dynamicRulePrecedences)prop[rule.id]=prec}let topRules=Object.create(null);for(let term of this.terms.tops)topRules[term.nodeName]=[table.find(state=>state.startRule==term).id,term.id];let precTable=data.storeArray(tokenPrec.concat(65535)),
{nodeProps,skippedTypes}=this.gatherNodeProps(nodeTypes);return{states:ext,stateData:data.finish(),goto:computeGotoTable(table),nodeNames:nodeTypes.filter(t=>t.id<minRepeatTerm).map(t=>t.nodeName).join(" "),nodeProps,skippedTypes,maxTerm,repeatNodeCount:nodeTypes.length-minRepeatTerm,tokenizers,tokenData,topRules,dialects:name$jscomp$0,dynamicPrecedences:prop,specialized:rules$jscomp$0,tokenPrec:precTable,termNames}}getParser(){let {states,stateData,goto,nodeNames,nodeProps:rawNodeProps,skippedTypes,
maxTerm,repeatNodeCount,tokenizers:rawTokenizers,tokenData,topRules,dialects,dynamicPrecedences,specialized:rawSpecialized,tokenPrec,termNames}=this.prepareParser(),specialized=rawSpecialized.map(v=>{if(v instanceof ExternalSpecializer){let ext=this.options.externalSpecializer(v.ast.id.name,this.termTable);return{term:v.term.id,get:(value,stack)=>ext(value,stack)<<1|("extend"==v.ast.type?1:0)}}return{term:v.token.id,get:value=>v.table[value]||-1}}),tokenizers=rawTokenizers.map(tok=>tok instanceof
ExternalTokenDeclaration?this.options.externalTokenizer(tok.id.name,this.termTable):tok.id);return lezer.Parser.deserialize({version:13,states,stateData,goto,nodeNames,maxTerm,repeatNodeCount,nodeProps:rawNodeProps.map(({prop,terms})=>[this.knownProps[prop].prop,...terms]),skippedNodes:skippedTypes,tokenData,tokenizers,context:this.ast.context?this.options.contextTracker:void 0,topRules,nested:this.nestedParsers.map(spec=>[spec.name,spec.source?this.options.nestedParser(spec.name,this.termTable):
{},spec.end.compile().toArray({},none$3),spec.placeholder.id]),dialects,dynamicPrecedences,specialized,tokenPrec,termNames})}getParserFile(){function specializationTableString(table){return"{__proto__:null,"+Object.keys(table).map(key=>`${/\W/.test(key)?JSON.stringify(key):key}:${table[key]}`).join(", ")+"}"}function serializePropValue(value){return"string"!=typeof value||/^(true|false|\d+(\.\d+)?|\.\d+)$/.test(value)?value:JSON.stringify(value)}let {states,stateData,goto,nodeNames,nodeProps:rawNodeProps,
skippedTypes,maxTerm,repeatNodeCount,tokenizers:rawTokenizers,tokenData,topRules,dialects:rawDialects,dynamicPrecedences,specialized:rawSpecialized,tokenPrec,termNames}=this.prepareParser(),mod=this.options.moduleStyle||"es",head;head="// This file was generated by lezer-generator. You probably shouldn't edit it.\n"+("cjs"==mod?'const {Parser} \x3d require("lezer")\n':'import {Parser} from "lezer"\n');let imports={},imported=Object.create(null),defined=Object.create(null),exportName=this.options.exportName||
"parser";defined.Parser=defined[exportName]=!0;let getName=prefix=>{for(let i=0;;i++){let id=prefix+(i?"_"+i:"");if(!defined[id])return id}},importName=(name,source,prefix)=>{let spec=name+" from "+source;if(imported[spec])return imported[spec];source=JSON.stringify(source);let varName=name;name in defined&&(varName=getName(prefix),name+=`${"cjs"==mod?":":" as"} ${varName}`);(imports[source]||(imports[source]=[])).push(name);return imported[spec]=varName};var tokenizers=rawTokenizers.map(tok=>{if(tok instanceof
ExternalTokenDeclaration){let {source,id:{name}}=tok;return importName(name,source,"tok")}return tok.id}),nested=this.nestedParsers.map(spec=>`[${JSON.stringify(spec.name)}, ${spec.source?importName(spec.extName,spec.source,spec.name):"{}"},\
${encodeArray(spec.end.compile().toArray({},none$3))}, ${spec.placeholder.id}]`),context=this.ast.context?importName(this.ast.context.id.name,this.ast.context.source,"cx"):null,nodeProps=rawNodeProps.map(({prop,terms})=>{({source:prop}=this.knownProps[prop]);return`[${prop.from?importName(prop.name,prop.from,"prop"):importName("NodeProp","lezer","NodeProp")+"."+prop.name}, ${terms.map(serializePropValue).join(",")}]`});let specHead="",specialized=rawSpecialized.map(v=>{if(v instanceof ExternalSpecializer){var name=
importName(v.ast.id.name,v.ast.source,v.ast.id.name);return`{term: ${v.term.id}, get: (value, stack) => (${name}(value, stack) << 1)${"extend"==v.ast.type?" | 1":""}}`}name=getName("spec_"+v.token.name.replace(/\W/g,""));specHead+=`const ${name} = ${specializationTableString(v.table)}\n`;return`{term: ${v.token.id}, get: value => ${name}[value] || -1}`});for(var source$jscomp$0 in imports)head="cjs"==mod?head+`const {${imports[source$jscomp$0].join(", ")}} = require(${source$jscomp$0})\n`:head+`import {${imports[source$jscomp$0].join(", ")}} from ${source$jscomp$0}\n`;
head+=specHead;source$jscomp$0=Object.keys(rawDialects).map(d=>`${d}: ${rawDialects[d]}`);tokenizers=`Parser.deserialize({
  version: ${13},
  states: ${encodeArray(states,4294967295)},
  stateData: ${encodeArray(stateData)},
  goto: ${encodeArray(goto)},
  nodeNames: ${JSON.stringify(nodeNames)},
  maxTerm: ${maxTerm}${context?`,
  context: ${context}`:""}${nodeProps.length?`,
  nodeProps: [
    ${nodeProps.join(",\n    ")}
  ]`:""}${skippedTypes.length?`,
  skippedNodes: ${JSON.stringify(skippedTypes)}`:""},
  repeatNodeCount: ${repeatNodeCount},
  tokenData: ${encodeArray(tokenData)},
  tokenizers: [${tokenizers.join(", ")}],
  topRules: ${JSON.stringify(topRules)}${nested.length?`,
  nested: [${nested.join(", ")}]`:""}${source$jscomp$0.length?`,
  dialects: {${source$jscomp$0.join(", ")}}`:""}${dynamicPrecedences?`,
  dynamicPrecedences: ${JSON.stringify(dynamicPrecedences)}`:""}${specialized.length?`,
  specialized: [${specialized.join(",")}]`:""},
  tokenPrec: ${tokenPrec}${this.options.includeNames?`,
  termNames: ${JSON.stringify(termNames)}`:""}
})`;nested=[];for(var name$jscomp$0 in this.termTable){context=name$jscomp$0;if(KEYWORDS.includes(context))for(nodeProps=1;context="_".repeat(nodeProps)+name$jscomp$0,context in this.termTable;nodeProps++);nested.push(`${context}${"cjs"==mod?":":" \x3d"} ${this.termTable[name$jscomp$0]}`)}for(name$jscomp$0=0;name$jscomp$0<this.dialects.length;name$jscomp$0++)nested.push(`Dialect_${this.dialects[name$jscomp$0]}${"cjs"==mod?":":" \x3d"} ${name$jscomp$0}`);return{parser:head+("cjs"==mod?`exports.${exportName} = ${tokenizers}\n`:
`export const ${exportName} = ${tokenizers}\n`),terms:"cjs"==mod?`${"// This file was generated by lezer-generator. You probably shouldn't edit it.\n"}module.exports = {\n  ${nested.join(",\n  ")}\n}`:`${"// This file was generated by lezer-generator. You probably shouldn't edit it.\n"}export const\n  ${nested.join(",\n  ")}\n`}}gatherNonSkippedNodes(){let seen=Object.create(null),work=[],add=term=>{seen[term.id]||(seen[term.id]=!0,work.push(term))};this.terms.tops.forEach(add);for(let i=0;i<work.length;i++)for(let rule of work[i].rules)for(let part of rule.parts)add(part);
return seen}gatherNodeProps(nodeTypes){let notSkipped=this.gatherNonSkippedNodes(),skippedTypes=[],nodeProps=[];for(let type of nodeTypes){notSkipped[type.id]||type.error||skippedTypes.push(type.id);for(let prop in type.props){nodeTypes=this.knownProps[prop];if(!nodeTypes)throw new GenError("No known prop type for "+prop);if(null!=nodeTypes.source.from||"repeated"!=nodeTypes.source.name&&"error"!=nodeTypes.source.name)(nodeTypes=nodeProps.find(r=>r.prop==prop))||nodeProps.push(nodeTypes={prop,values:{}}),
(nodeTypes.values[type.props[prop]]||(nodeTypes.values[type.props[prop]]=[])).push(type.id)}}return{nodeProps:nodeProps.map(({prop,values})=>{let terms=[];for(let val in values){let ids=values[val];if(1==ids.length)terms.push(ids[0],val);else{terms.push(-ids.length);for(let id of ids)terms.push(id);terms.push(val)}}return{prop,terms}}),skippedTypes}}addNestedParsers(table){for(let state of table)if(table=state.set.filter(pos=>this.nestedParsers.some(g=>g.placeholder==pos.next)),table.length){let placeholder=
table[0].next;table.every(pos=>pos.next==placeholder)||this.raise(`Multiple nested grammars possible after ${table[0].trail()}`);state.set.every(pos=>pos.next==placeholder||0==pos.pos&&state.set.some(p=>p.next==pos.rule.name))||this.raise(`Nested grammar in ambiguous position after ${table[0].trail()} `+state.set);state.nested=this.nestedParsers.findIndex(g=>g.placeholder==placeholder)}}makeTerminal(name,tag,props){return this.terms.makeTerminal(this.terms.uniqueName(name),tag,props)}computeForceReductions(states,
skipInfo){function createsCycle(term,startState,parents=null){return(term=gotoEdges[term])?term.some(val=>{let parentIntersection=parents?parents.filter(id=>val.parents.includes(id)):val.parents;if(0==parentIntersection.length)return!1;if(val.target==startState)return!0;let found=length1Reductions[val.target];return null!=found&&createsCycle(found,startState,parentIntersection)}):!1}let reductions=[],candidates=[],gotoEdges=Object.create(null);for(var state$jscomp$0 of states){reductions.push(0);
for(let edge of state$jscomp$0.goto){var array=gotoEdges[edge.term.id]||(gotoEdges[edge.term.id]=[]),found$jscomp$0=array.find(o=>o.target==edge.target.id);found$jscomp$0?found$jscomp$0.parents.push(state$jscomp$0.id):array.push({parents:[state$jscomp$0.id],target:edge.target.id})}candidates[state$jscomp$0.id]=state$jscomp$0.set.filter(pos=>0<pos.pos&&!pos.rule.name.top).sort((a,b)=>b.pos-a.pos||a.rule.parts.length-b.rule.parts.length)}let length1Reductions=Object.create(null);for(let state of states)state.defaultReduce&&
0<state.defaultReduce.parts.length&&(reductions[state.id]=reduceAction(state.defaultReduce,skipInfo),1==state.defaultReduce.parts.length&&(length1Reductions[state.id]=state.defaultReduce.name.id));for(state$jscomp$0=1;;state$jscomp$0++){array=!0;for(let state of states)if(!state.defaultReduce)if(found$jscomp$0=candidates[state.id],found$jscomp$0.length!=state$jscomp$0)found$jscomp$0.length>state$jscomp$0&&(array=!1);else for(let pos of found$jscomp$0)if(1!=pos.pos||!createsCycle(pos.rule.name.id,
state.id)){reductions[state.id]=reduceAction(pos.rule,skipInfo,pos.pos);1==pos.pos&&(length1Reductions[state.id]=pos.rule.name.id);break}if(array)break}return reductions}substituteArgs(expr$jscomp$0,args,params){return 0==args.length?expr$jscomp$0:expr$jscomp$0.walk(expr=>{var found;if(expr instanceof NameExpression&&!expr.namespace&&-1<(found=params.findIndex(p=>p.name==expr.id.name))){found=args[found];if(expr.args.length){if(found instanceof NameExpression&&!found.args.length)return new NameExpression(expr.start,
found.namespace,found.id,expr.args);this.raise("Passing arguments to a parameter that already has arguments",expr.start)}return found}if(expr instanceof InlineRuleExpression){found=expr.rule;let props=this.substituteArgsInProps(found.props,args,params);return props==found.props?expr:new InlineRuleExpression(expr.start,new RuleDeclaration(found.start,found.id,props,found.params,found.expr))}return expr instanceof SpecializeExpression?(found=this.substituteArgsInProps(expr.props,args,params),found==
expr.props?expr:new SpecializeExpression(expr.start,expr.type,found,expr.token,expr.content)):expr})}substituteArgsInProps(props,args,params){let substituteInValue=value=>{let result=value;for(let i=0;i<value.length;i++){let part=value[i];if(part.name){var found=params.findIndex(p=>p.name==part.name);0>found||(result==value&&(result=value.slice()),found=args[found],found instanceof NameExpression&&!found.namespace&&!found.args.length?result[i]=new PropPart(part.start,found.id.name,null):found instanceof
LiteralExpression?result[i]=new PropPart(part.start,found.value,null):this.raise(`Trying to interpolate expression '${found}' into a prop`,part.start))}}return result},result$jscomp$0=props;for(let i=0;i<props.length;i++){let prop=props[i],value=substituteInValue(prop.value);value!=prop.value&&(result$jscomp$0==props&&(result$jscomp$0=props.slice()),result$jscomp$0[i]=new Prop(prop.start,prop.at,prop.name,value))}return result$jscomp$0}conflictsFor(markers){let here=Conflicts.none,atEnd=Conflicts.none;
for(let marker of markers)if("ambig"==marker.type)here=here.join(new Conflicts(0,[marker.id.name]));else{var precs=this.ast.precedences;let index=precs?precs.items.findIndex(item=>item.id.name==marker.id.name):-1;0>index&&this.raise(`Reference to unknown precedence: '${marker.id.name}'`,marker.id.start);markers=precs.items[index];precs=precs.items.length-index;"cut"==markers.type?here=here.join(new Conflicts(0,none$3,precs)):(here=here.join(new Conflicts(precs<<2)),atEnd=atEnd.join(new Conflicts((precs<<
2)+("left"==markers.type?1:"right"==markers.type?-1:0))))}return{here,atEnd}}raise(message,pos=1){return this.input.raise(message,pos)}warn(message,pos=-1){message=this.input.message(message,pos);this.options.warn?this.options.warn(message):console.warn(message)}defineRule(name,choices){let skip=this.currentSkip[this.currentSkip.length-1];for(let choice of choices)this.rules.push(new Rule(name,choice.terms,choice.ensureConflicts(),skip))}resolve(expr){if(expr.namespace){var ns=this.namespaces[expr.namespace.name];
ns||this.raise(`Reference to undefined namespace '${expr.namespace.name}'`,expr.start);return ns.resolve(expr,this)}for(var built of this.built)if(built.matches(expr))return[p$jscomp$0(built.term)];if(built=this.tokens.getToken(expr))return[p$jscomp$0(built)];for(var ext of this.externalTokens)if(built=ext.getToken(expr))return[p$jscomp$0(built)];for(ns of this.externalSpecializers)if(ext=ns.getToken(expr))return[p$jscomp$0(ext)];ns=this.astRules.find(r=>r.rule.id.name==expr.id.name);if(!ns)return this.raise(`Reference to undefined rule '${expr.id.name}'`,
expr.start);ns.rule.params.length!=expr.args.length&&this.raise(`Wrong number or arguments for '${expr.id.name}'`,expr.start);this.used(ns.rule.id.name);return[p$jscomp$0(this.buildRule(ns.rule,expr.args,ns.skip))]}normalizeRepeat(expr){var known=this.built.find(b=>b.matchesRepeat(expr));if(known)return p$jscomp$0(known.term);known=this.terms.makeRepeat(this.terms.uniqueName(expr.expr.prec<expr.prec?`(${expr.expr})+`:`${expr.expr}+`));this.built.push(new BuiltRule("+",[expr.expr],known));this.defineRule(known,
this.normalizeExpr(expr.expr).concat(p$jscomp$0(known,known)));return p$jscomp$0(known)}normalizeSequence(expr){function complete(start,from,endConflicts){let {here,atEnd}=builder.conflictsFor(expr.markers[from]);if(from==result.length)return[start.withConflicts(start.terms.length,here.join(endConflicts))];let choices=[];for(let choice of result[from])for(let full of complete(start.concat(choice).withConflicts(start.terms.length,here),from+1,endConflicts.join(atEnd)))choices.push(full);return choices}
let result=expr.exprs.map(e=>this.normalizeExpr(e)),builder=this;return complete(Parts.none,0,Conflicts.none)}normalizeExpr(expr){if(expr instanceof RepeatExpression&&"?"==expr.kind)return[Parts.none,...this.normalizeExpr(expr.expr)];if(expr instanceof RepeatExpression){let repeated=this.normalizeRepeat(expr);return"+"==expr.kind?[repeated]:[Parts.none,repeated]}return expr instanceof ChoiceExpression?expr.exprs.reduce((o,e)=>o.concat(this.normalizeExpr(e)),[]):expr instanceof SequenceExpression?
this.normalizeSequence(expr):expr instanceof LiteralExpression?[p$jscomp$0(this.tokens.getLiteral(expr))]:expr instanceof NameExpression?this.resolve(expr):expr instanceof SpecializeExpression?[p$jscomp$0(this.resolveSpecialization(expr))]:expr instanceof InlineRuleExpression?[p$jscomp$0(this.buildRule(expr.rule,none$3,this.currentSkip[this.currentSkip.length-1],!0))]:this.raise(`This type of expression ('${expr}') may not occur in non-token rules`,expr.start)}buildRule(rule,args,skip,inline=!1){let expr=
this.substituteArgs(rule.expr,args,rule.params),{name:nodeName,props,dynamicPrec,inline:explicitInline,group,exported}=this.nodeInfo(rule.props||none$3,inline?"pg":"pgi",rule.id.name,args,rule.params,rule.expr);exported&&rule.params.length&&this.warn("Can't export parameterized rules",rule.start);let name=this.newName(rule.id.name+(args.length?"\x3c"+args.join(",")+"\x3e":""),nodeName||!0,props);explicitInline&&(name.inline=!0);dynamicPrec&&this.registerDynamicPrec(name,dynamicPrec);(name.nodeType||
exported)&&0==rule.params.length&&(nodeName||(name.preserve=!0),inline||(this.namedTerms[rule.id.name]=name));inline||this.built.push(new BuiltRule(rule.id.name,args,name));this.currentSkip.push(skip);this.defineRule(name,this.normalizeExpr(expr));this.currentSkip.pop();group&&this.definedGroups.push({name,group,rule});return name}nodeInfo(props,allow,defaultName=null,args=none$3,params=none$3,expr,defaultProps){let result={};var JSCompiler_temp;(JSCompiler_temp=defaultName)&&!(JSCompiler_temp=-1<
allow.indexOf("t"))&&(JSCompiler_temp=defaultName[0],JSCompiler_temp=!("_"==JSCompiler_temp||JSCompiler_temp.toUpperCase()!=JSCompiler_temp));JSCompiler_temp=JSCompiler_temp&&!/ /.test(defaultName)?defaultName:null;var dialect=null;let dynamicPrec=0,inline=!1,group=null,exported=!1;for(let prop of props)if(prop.at)"name"==prop.name?(JSCompiler_temp=this.finishProp(prop,args,params),/ /.test(JSCompiler_temp)&&this.raise(`Node names cannot have spaces ('${JSCompiler_temp}')`,prop.start)):"dialect"==
prop.name?(0>allow.indexOf("d")&&this.raise("Can't specify a dialect on non-token rules",props[0].start),1==prop.value.length||prop.value[0].value||this.raise("The '@dialect' rule prop must hold a plain string value"),dialect=this.dialects.indexOf(prop.value[0].value),0>dialect&&this.raise(`Unknown dialect '${prop.value[0].value}'`,prop.value[0].start)):"dynamicPrecedence"==prop.name?(0>allow.indexOf("p")&&this.raise("Dynamic precedence can only be specified on nonterminals"),1==prop.value.length&&
/^-?(?:10|\d)$/.test(prop.value[0].value)||this.raise("The '@dynamicPrecedence' rule prop must hold an integer between -10 and 10"),dynamicPrec=+prop.value[0].value):"inline"==prop.name?(prop.value.length&&this.raise("'@inline' doesn't take a value",prop.value[0].start),0>allow.indexOf("i")&&this.raise("Inline can only be specified on nonterminals"),inline=!0):"isGroup"==prop.name?(0>allow.indexOf("g")&&this.raise("'@isGroup' can only be specified on nonterminals"),group=prop.value.length?this.finishProp(prop,
args,params):defaultName):"export"==prop.name?(prop.value.length&&this.raise("'@export' doesn't take a value",prop.value[0].start),exported=!0):this.raise(`Unknown built-in prop name '@${prop.name}'`,prop.start);else{if(!this.knownProps[prop.name]){let builtin=["name","dialect","dynamicPrecedence","export","isGroup"].includes(prop.name)?` (did you mean '@${prop.name}'?)`:"";this.raise(`Unknown prop name '${prop.name}'${builtin}`,prop.start)}result[prop.name]=this.finishProp(prop,args,params)}expr&&
this.ast.autoDelim&&(JSCompiler_temp||hasProps(result))&&(allow=this.findDelimiters(expr))&&(addToProp(allow[0],"closedBy",allow[1].nodeName),addToProp(allow[1],"openedBy",allow[0].nodeName));if(defaultProps&&hasProps(defaultProps))for(let prop in defaultProps)prop in result||(result[prop]=defaultProps[prop]);hasProps(result)&&!JSCompiler_temp&&this.raise("Node has properties but no name",props.length?props[0].start:expr.start);inline&&(hasProps(result)||dialect||dynamicPrec)&&this.raise("Inline nodes can't have props, dynamic precedence, or a dialect",
props[0].start);inline&&JSCompiler_temp&&(JSCompiler_temp=null);return{name:JSCompiler_temp,props:result,dialect,dynamicPrec,inline,group,exported}}finishProp(prop,args,params){return prop.value.map(part=>{if(part.value)return part.value;var pos=params.findIndex(param=>param.name==part.name);0>pos&&this.raise(`Property refers to '${part.name}', but no parameter by that name is in scope`,part.start);pos=args[pos];return pos instanceof NameExpression&&!pos.args.length&&!pos.namespace?pos.id.name:pos instanceof
LiteralExpression?pos.value:this.raise(`Expression '${pos}' can not be used as part of a property value`,part.start)}).join("")}resolveSpecialization(expr$jscomp$0){let type=expr$jscomp$0.type,{name,props,dialect}=this.nodeInfo(expr$jscomp$0.props,"d");var terminal=this.normalizeExpr(expr$jscomp$0.token);1==terminal.length&&1==terminal[0].terms.length&&terminal[0].terms[0].terminal||this.raise(`The first argument to '${type}' must resolve to a token`,expr$jscomp$0.token.start);if(expr$jscomp$0.content instanceof
LiteralExpression)var values=[expr$jscomp$0.content.value];else if(expr$jscomp$0.content instanceof ChoiceExpression&&expr$jscomp$0.content.exprs.every(e=>e instanceof LiteralExpression))values=expr$jscomp$0.content.exprs.map(expr=>expr.value);else return this.raise(`The second argument to '${expr$jscomp$0.type}' must be a literal or choice of literals`,expr$jscomp$0.content.start);terminal=terminal[0].terms[0];let token=null,table=this.specialized[terminal.name]||(this.specialized[terminal.name]=
[]);for(let value of values)values=table.find(sp=>sp.value==value),null==values?(token||(token=this.makeTerminal(terminal.name+"/"+JSON.stringify(value),name,props),null!=dialect&&(this.tokens.byDialect[dialect]||(this.tokens.byDialect[dialect]=[])).push(token)),table.push({value,term:token,type,dialect,name}),this.tokenOrigins[token.name]={spec:terminal}):(values.type!=type&&this.raise(`Conflicting specialization types for ${JSON.stringify(value)} of ${terminal.name} (${type} vs ${values.type})`,
expr$jscomp$0.start),values.dialect!=dialect&&this.raise(`Conflicting dialects for specialization ${JSON.stringify(value)} of ${terminal.name}`,expr$jscomp$0.start),values.name!=name&&this.raise(`Conflicting names for specialization ${JSON.stringify(value)} of ${terminal.name}`,expr$jscomp$0.start),token&&values.term!=token&&this.raise(`Conflicting specialization tokens for ${JSON.stringify(value)} of ${terminal.name}`,expr$jscomp$0.start),token=values.term);return token}findDelimiters(expr$jscomp$0){if(!(expr$jscomp$0 instanceof
SequenceExpression)||2>expr$jscomp$0.exprs.length)return null;let findToken=expr=>{if(expr instanceof LiteralExpression)return{term:this.tokens.getLiteral(expr),str:expr.value};if(expr instanceof NameExpression&&0==expr.args.length){var rule=this.ast.rules.find(r=>r.id.name==expr.id.name);if(rule)return findToken(rule.expr);if((rule=this.tokens.rules.find(r=>r.id.name==expr.id.name))&&rule.expr instanceof LiteralExpression)return{term:this.tokens.getToken(expr),str:rule.expr.value}}return null},lastToken=
findToken(expr$jscomp$0.exprs[expr$jscomp$0.exprs.length-1]);if(!lastToken||!lastToken.term.nodeName)return null;let bracket=["()","[]","{}","\x3c\x3e"].find(b=>-1<lastToken.str.indexOf(b[1])&&0>lastToken.str.indexOf(b[0]));if(!bracket)return null;expr$jscomp$0=findToken(expr$jscomp$0.exprs[0]);return!expr$jscomp$0||!expr$jscomp$0.term.nodeName||0>expr$jscomp$0.str.indexOf(bracket[0])||-1<expr$jscomp$0.str.indexOf(bracket[1])?null:[expr$jscomp$0.term,lastToken.term]}registerDynamicPrec(term,prec){this.dynamicRulePrecedences.push({rule:term,
prec});term.preserve=!0}defineGroup(rule$jscomp$0,group,ast){var _a;let recur=[],getNamed=rule=>{if(rule.nodeName)return[rule];recur.includes(rule)&&this.raise(`Rule '${ast.id.name}' cannot define a group because it contains a non-named recursive rule ('${rule.name}')`,ast.start);let result=[];recur.push(rule);for(let r of this.rules)if(r.name==rule){let names=r.parts.map(getNamed).filter(x=>x.length);1<names.length&&this.raise(`Rule '${ast.id.name}' cannot define a group because some choices produce multiple named nodes`,
ast.start);if(1==names.length)for(let n of names[0])result.push(n)}recur.pop();return result};for(let name of getNamed(rule$jscomp$0))name.props.group=((null===(_a=name.props.group)||void 0===_a?void 0:_a.split(" "))||[]).concat(group).sort().join(" ")}checkGroups(){let groups=Object.create(null),nodeNames=Object.create(null);for(var term of this.terms.terms)if(term.nodeName&&(nodeNames[term.nodeName]=!0,term.props.group))for(var group of term.props.group.split(" "))(groups[group]||(groups[group]=
[])).push(term);term=Object.keys(groups);for(group=0;group<term.length;group++){let name=term[group],terms=groups[name];nodeNames[name]&&this.warn(`Group name '${name}' conflicts with a node of the same name`);for(let j=group+1;j<term.length;j++){let other=groups[term[j]];terms.some(t=>other.includes(t))&&(terms.length>other.length?other.some(t=>!terms.includes(t)):terms.some(t=>!other.includes(t)))&&this.warn(`Groups '${name}' and '${term[j]}' overlap without one being a superset of the other`)}}}}
class FinishStateContext{constructor(tokenizers,data,stateArray,skipData,skipInfo,states,builder){this.tokenizers=tokenizers;this.data=data;this.stateArray=stateArray;this.skipData=skipData;this.skipInfo=skipInfo;this.states=states;this.builder=builder;this.sharedActions=[]}findSharedActions(state){if(5>state.actions.length)return null;var found=null;for(var shared of this.sharedActions)(!found||shared.actions.length>found.actions.length)&&shared.actions.every(a=>state.actions.some(b=>b.eq(a)))&&
(found=shared);if(found)return found;found=null;shared=[];for(let i=state.id+1;i<this.states.length;i++){let other=this.states[i],fill=0;if(!(other.defaultReduce||5>other.actions.length)){for(var a$jscomp$0 of state.actions)for(let b of other.actions)a$jscomp$0.eq(b)&&(shared[fill++]=a$jscomp$0);5<=fill&&(!found||found.length<fill)&&(found=shared,shared=[])}}if(!found)return null;a$jscomp$0={actions:found,addr:this.storeActions(found,-1,null)};this.sharedActions.push(a$jscomp$0);return a$jscomp$0}storeActions(actions,
skipReduce,shared){if(0>skipReduce&&shared&&shared.actions.length==actions.length)return shared.addr;let data=[];for(let action of actions)shared&&shared.actions.some(a=>a.eq(action))||(action instanceof Shift?data.push(action.term.id,action.target.id,0):(actions=reduceAction(action.rule,this.skipInfo),actions!=skipReduce&&data.push(action.term.id,actions&65535,actions>>16)));data.push(65535);-1<skipReduce?data.push(2,skipReduce&65535,skipReduce>>16):shared?data.push(1,shared.addr&65535,shared.addr>>
16):data.push(0);return this.data.storeArray(data)}finish(state,isSkip,forcedReduce){var b$jscomp$0=this.builder,skipID=b$jscomp$0.skipRules.indexOf(state.skip);let skipTable=this.skipData[skipID];var skipTerms=this.skipInfo[skipID].startTokens;skipID=state.defaultReduce?reduceAction(state.defaultReduce,this.skipInfo):0;isSkip=(isSkip?1:0)|(-1<state.nested?4|state.nested<<10:0);let skipReduce=-1,shared=null;if(0==skipID){for(const action of state.actions)action instanceof Reduce&&action.term.eof&&
this.skipInfo.some(i=>i.rule==action.rule.name)&&(skipReduce=reduceAction(action.rule,this.skipInfo));0>skipReduce&&(shared=this.findSharedActions(state))}state.set.some(p=>p.rule.name.top&&p.pos==p.rule.parts.length)&&(isSkip|=2);var external=[];for(var i$jscomp$0=0;i$jscomp$0<state.actions.length+skipTerms.length;i$jscomp$0++)for(var term=i$jscomp$0<state.actions.length?state.actions[i$jscomp$0].term:skipTerms[i$jscomp$0-state.actions.length];;)if((term=b$jscomp$0.tokenOrigins[term.name])&&term.spec)term=
term.spec;else{term&&term.external instanceof ExternalTokenSet&&addToSet(external,term.external.ast);break}external.sort((a,b)=>a.start-b.start);b$jscomp$0=0;for(skipTerms=0;skipTerms<this.tokenizers.length;skipTerms++)if(i$jscomp$0=this.tokenizers[skipTerms],i$jscomp$0 instanceof ExternalTokenDeclaration?external.includes(i$jscomp$0):i$jscomp$0.id==state.tokenGroup)b$jscomp$0|=1<<skipTerms;external=6*state.id;this.stateArray[external+0]=isSkip;this.stateArray[external+1]=this.storeActions(skipID?
none$3:state.actions,skipReduce,shared);this.stateArray[external+2]=skipTable;this.stateArray[external+3]=b$jscomp$0;this.stateArray[external+4]=skipID;this.stateArray[external+5]=forcedReduce}}class DataBuilder{constructor(){this.data=[]}storeArray(data){a:{var JSCompiler_inline_result=this.data;b:for(var i=0;;){i=JSCompiler_inline_result.indexOf(data[0],i);if(-1==i||i+data.length>JSCompiler_inline_result.length)break;for(let j=1;j<data.length;j++)if(data[j]!=JSCompiler_inline_result[i+j]){i+=1;
continue b}JSCompiler_inline_result=i;break a}JSCompiler_inline_result=-1}if(-1<JSCompiler_inline_result)return JSCompiler_inline_result;JSCompiler_inline_result=this.data.length;for(let num of data)this.data.push(num);return JSCompiler_inline_result}finish(){return Uint16Array.from(this.data)}}class TokenGroup{constructor(tokens,id){this.tokens=tokens;this.id=id}}class NestedParserSpec{constructor(placeholder,name,extName,source,end){this.placeholder=placeholder;this.name=name;this.extName=extName;
this.source=source;this.end=end}}class NestNamespace{resolve(expr,builder){2<expr.args.length&&builder.raise(`Too many arguments to 'nest.${expr.id.name}'`,expr.start);let [endExpr,defaultExpr]=expr.args,extGrammar=builder.ast.grammars.find(g=>g.id.name==expr.id.name);if(!extGrammar)return builder.raise(`No external grammar '${expr.id.name}' defined`,expr.id.start);let placeholder=builder.newName(expr.id.name+"-placeholder",!0);builder.defineRule(placeholder,defaultExpr?builder.normalizeExpr(defaultExpr):
[]);if(!endExpr&&!(endExpr=findExprAfter(builder.ast,expr)))return builder.raise("No end token specified, and no token found directly after the nest expression",expr.start);let endStart=new State,endEnd=new State([builder.terms.eof]);try{builder.tokens.build(endExpr,endStart,endEnd,none$3)}catch(e){if(!(e instanceof SyntaxError))throw e;builder.raise(`End token '${endExpr}' for nested grammar is not a valid token expression`,endExpr.start)}builder.nestedParsers.push(new NestedParserSpec(placeholder,
extGrammar.id.name,extGrammar.externalID.name,extGrammar.source,endStart));builder.nestedParsers.length>=2**20&&builder.raise("Too many nested grammars used");return[p$jscomp$0(placeholder)]}}class TokenArg{constructor(name,expr,scope){this.name=name;this.expr=expr;this.scope=scope}}class BuildingRule{constructor(name,start,to,args){this.name=name;this.start=start;this.to=to;this.args=args}}class TokenSet{constructor(b,ast){this.b=b;this.ast=ast;this.startState=new State;this.built=[];this.building=
[];this.byDialect=Object.create(null);this.precedenceRelations=[];this.explicitConflicts=[];this.rules=ast?ast.rules:none$3;for(let rule of this.rules)this.b.unique(rule.id)}getToken(expr){for(var built of this.built)if(built.matches(expr))return built.term;let name=expr.id.name;built=this.rules.find(r=>r.id.name==name);if(!built)return null;let {name:nodeName,props,dialect,exported}=this.b.nodeInfo(built.props,"d",name,expr.args,built.params.length!=expr.args.length?none$3:built.params),term=this.b.makeTerminal(expr.toString(),
nodeName,props);null!=dialect&&(this.byDialect[dialect]||(this.byDialect[dialect]=[])).push(term);(term.nodeType||exported)&&0==built.params.length&&(term.nodeType||(term.preserve=!0),this.b.namedTerms[name]=term);this.buildRule(built,expr,this.startState,new State([term]));this.built.push(new BuiltRule(name,expr.args,term));return term}getLiteral(expr){let id=JSON.stringify(expr.value);for(var built of this.built)if(built.id==id)return built.term;var name=null;let props={};built=null;let decl=this.ast?
this.ast.literals.find(l=>l.literal==expr.value):null;decl&&({name,props,dialect:built}=this.b.nodeInfo(decl.props,"d",expr.value));name=this.b.makeTerminal(id,name,props);null!=built&&(this.byDialect[built]||(this.byDialect[built]=[])).push(name);this.build(expr,this.startState,new State([name]),none$3);this.built.push(new BuiltRule(id,none$3,name));return name}buildRule(rule,expr,from,to,args=none$3){let name=expr.id.name;rule.params.length!=expr.args.length&&this.b.raise(`Incorrect number of arguments for token '${name}'`,
expr.start);var building=this.building.find(b=>b.name==name&&exprsEq(expr.args,b.args));if(building){if(building.to==to){from.nullEdge(building.start);return}for(building=this.building.length-1;this.building[building].name!=name;)building--;this.b.raise(`Invalid (non-tail) recursion in token rules: ${this.building.slice(building).map(b=>b.name).join(" -\x3e ")}`,expr.start)}this.b.used(rule.id.name);building=new State;from.nullEdge(building);this.building.push(new BuildingRule(name,building,to,expr.args));
this.build(this.b.substituteArgs(rule.expr,expr.args,rule.params),building,to,expr.args.map((e,i)=>new TokenArg(rule.params[i].name,e,args)));this.building.pop()}build(expr,from,to,args){if(expr instanceof NameExpression){if(expr.namespace){if("std"==expr.namespace.name)return this.buildStd(expr,from,to);this.b.raise(`Unknown namespace '${expr.namespace.name}'`,expr.start)}let name=expr.id.name;var arg=args.find(a=>a.name==name);if(arg)return this.build(arg.expr,from,to,arg.scope);arg=this.rules.find(r=>
r.id.name==name);if(!arg)return this.b.raise(`Reference to rule '${expr.id.name}', which isn't found in this token group`,expr.start);this.buildRule(arg,expr,from,to,args)}else if(expr instanceof ChoiceExpression)for(arg of expr.exprs)this.build(arg,from,to,args);else if(isEmpty(expr))from.nullEdge(to);else if(expr instanceof SequenceExpression)for((arg=expr.markers.find(c=>0<c.length))&&this.b.raise("Conflict marker in token expression",arg[0].start),arg=0;arg<expr.exprs.length;arg++){var next=arg==
expr.exprs.length-1?to:new State;this.build(expr.exprs[arg],from,next,args);from=next}else if(expr instanceof RepeatExpression)"*"==expr.kind?(arg=new State,from.nullEdge(arg),this.build(expr.expr,arg,arg,args),arg.nullEdge(to)):"+"==expr.kind?(arg=new State,this.build(expr.expr,from,arg,args),this.build(expr.expr,arg,arg,args),arg.nullEdge(to)):(from.nullEdge(to),this.build(expr.expr,from,to,args));else if(expr instanceof SetExpression)for(let [a,b]of expr.inverted?invertRanges(expr.ranges):expr.ranges)rangeEdges(from,
to,a,b);else if(expr instanceof LiteralExpression)for(args=0;args<expr.value.length;args++)arg=expr.value.charCodeAt(args),next=args==expr.value.length-1?to:new State,from.edge(arg,arg+1,next),from=next;else if(expr instanceof AnyExpression)from.edge(0,65535,to);else return this.b.raise("Unrecognized expression type in token",expr.start)}buildStd(expr,from,to){expr.args.length&&this.b.raise(`'std.${expr.id.name}' does not take arguments`,expr.args[0].start);STD_RANGES.hasOwnProperty(expr.id.name)||
this.b.raise(`There is no builtin rule 'std.${expr.id.name}'`,expr.start);for(let [a,b]of STD_RANGES[expr.id.name])from.edge(a,b,to)}takePrecedences(){let rel=this.precedenceRelations=[];if(this.ast)for(let group of this.ast.precedences){let prev=[];for(let item of group.items){let level=[];if(item instanceof NameExpression)for(let built of this.built)(item.args.length?built.matches(item):built.id==item.id.name)&&level.push(built.term);else{let id=JSON.stringify(item.value),found=this.built.find(b=>
b.id==id);found&&level.push(found.term)}level.length||this.b.warn(`Precedence specified for unknown token ${item}`,item.start);for(let term of level)addRel(rel,term,prev);prev=prev.concat(level)}}}takeConflicts(){var _a;let resolve=expr=>{if(expr instanceof NameExpression)for(var built of this.built){if(built.matches(expr))return built.term}else{let id=JSON.stringify(expr.value);if(built=this.built.find(b=>b.id==id))return built.term}this.b.warn(`Precedence specified for unknown token ${expr}`,expr.start);
return null};for(let c of(null===(_a=this.ast)||void 0===_a?void 0:_a.conflicts)||[]){_a=resolve(c.a);let b=resolve(c.b);_a&&b&&(_a.id<b.id&&([_a,b]=[b,_a]),this.explicitConflicts.push({a:_a,b}))}}precededBy(a,b){let found=this.precedenceRelations.find(r=>r.term==a);return found&&found.after.includes(b)}buildTokenGroups(states,skipInfo){let tokens=this.startState.compile();tokens.accepting.length&&this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`,this.rules.find(r=>
r.id.name==tokens.accepting[0].name).start);/\btokens\b/.test(verbose)&&console.log(tokens.toString());let allConflicts=tokens.findConflicts(checkTogether(states,this.b,skipInfo)).filter(({a,b})=>!this.precededBy(a,b)&&!this.precededBy(b,a));for(let {a,b}of this.explicitConflicts)allConflicts.some(c=>c.a==a&&c.b==b)||allConflicts.push(new Conflict(a,b,0,"",""));var softConflicts=allConflicts.filter(c=>c.soft),conflicts=allConflicts.filter(c=>!c.soft);let errors=[],groups=[];for(let state of states){if(state.defaultReduce)continue;
states=[];let incompatible=[];var skip=skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens;for(let term of skip)state.actions.some(a=>a.term==term)&&this.b.raise(`Use of token ${term.name} conflicts with skip rule`);var stateTerms=[];for(var i=0;i<state.actions.length+(skip?skip.length:0);i++){let term=i<state.actions.length?state.actions[i].term:skip[i-state.actions.length],orig=this.b.tokenOrigins[term.name];if(orig&&orig.spec)term=orig.spec;else if(orig&&orig.external)continue;addToSet(stateTerms,
term)}if(0!=stateTerms.length){for(let term of stateTerms)for(let conflict of conflicts)if(skip=conflict.a==term?conflict.b:conflict.b==term?conflict.a:null)stateTerms.includes(skip)&&!errors.some(e=>e.conflict==conflict)&&(i=conflict.exampleA?` (example: ${JSON.stringify(conflict.exampleA)}${conflict.exampleB?` vs ${JSON.stringify(conflict.exampleB)}`:""})`:"",errors.push({error:`Overlapping tokens ${term.name} and ${skip.name} used in same context${i}\n`+`After: ${state.set[0].trail()}`,conflict})),
addToSet(states,term),addToSet(incompatible,skip);stateTerms=null;for(let group of groups)if(!incompatible.some(term=>group.tokens.includes(term))){for(let term of states)addToSet(group.tokens,term);stateTerms=group;break}stateTerms||(stateTerms=new TokenGroup(states,groups.length),groups.push(stateTerms));state.tokenGroup=stateTerms.id}}errors.length&&this.b.raise(errors.map(e=>e.error).join("\n\n"));16<groups.length&&this.b.raise(`Too many different token groups (${groups.length}) to represent them as a 16-bit bitfield`);
let precTable=[];skipInfo=this.precedenceRelations.slice();for(let {a,b,soft}of softConflicts)soft&&skipInfo.some(r=>r.term==a)&&skipInfo.some(r=>r.term==b)&&(0>soft&&([a,b]=[b,a]),addRel(skipInfo,b,[a]),addRel(skipInfo,a,[]));a:for(;skipInfo.length;){for(softConflicts=0;softConflicts<skipInfo.length;softConflicts++)if(conflicts=skipInfo[softConflicts],conflicts.after.every(t=>precTable.includes(t.id))){precTable.push(conflicts.term.id);if(1==skipInfo.length)break a;skipInfo[softConflicts]=skipInfo.pop();
continue a}this.b.raise(`Cyclic token precedence relation between ${skipInfo.map(r=>r.term).join(", ")}`)}precTable=precTable.filter(id=>allConflicts.some(c=>!c.soft&&(c.a.id==id||c.b.id==id)));return{tokenGroups:groups,tokenPrec:precTable,tokenData:tokens.toArray(buildTokenMasks(groups),precTable)}}}const STD_RANGES={asciiLetter:[[65,91],[97,123]],asciiLowercase:[[97,123]],asciiUppercase:[[65,91]],digit:[[48,58]],whitespace:[[9,14],[32,33],[133,134],[160,161],[5760,5761],[8192,8203],[8232,8234],
[8239,8240],[8287,8288],[12288,12289]]};class ExternalTokenSet{constructor(b,ast){this.b=b;this.ast=ast;this.tokens=gatherExtTokens(b,ast.tokens);for(let name in this.tokens)this.b.tokenOrigins[this.tokens[name].name]={external:this}}getToken(expr){return findExtToken(this.b,this.tokens,expr)}}class ExternalSpecializer{constructor(b,ast){this.b=b;this.ast=ast;this.term=null;this.tokens=gatherExtTokens(b,ast.tokens)}finish(){let terms=this.b.normalizeExpr(this.ast.token);1==terms.length&&1==terms[0].terms.length&&
terms[0].terms[0].terminal||this.b.raise(`The token expression to '@external ${this.ast.type}' must resolve to a token`,this.ast.token.start);this.term=terms[0].terms[0];for(let name in this.tokens)this.b.tokenOrigins[this.tokens[name].name]={spec:this.term,external:this}}getToken(expr){return findExtToken(this.b,this.tokens,expr)}}const KEYWORDS="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this const class extends export import super enum implements interface let package private protected public static yield".split(" ");
exports.GenError=GenError;exports.buildParser=function(text,options={}){return(new Builder(text,options)).getParser()};exports.buildParserFile=function(text,options={}){return(new Builder(text,options)).getParserFile()}}
//# sourceMappingURL=module$node_modules$lezer_generator$dist$index_cjs.js.map
