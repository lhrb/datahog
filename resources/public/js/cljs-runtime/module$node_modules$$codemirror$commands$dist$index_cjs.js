shadow$provide.module$node_modules$$codemirror$commands$dist$index_cjs=function(global,require,module,exports){function updateSel(sel,by){return state$jscomp$0.EditorSelection.create(sel.ranges.map(by),sel.mainIndex)}function setSel(state$1,selection){return state$1.update({selection,scrollIntoView:!0,annotations:state$jscomp$0.Transaction.userEvent.of("keyboardselection")})}function moveSel({state,dispatch},how){how=updateSel(state.selection,how);if(how.eq(state.selection))return!1;dispatch(setSel(state,
how));return!0}function rangeEnd(range,forward){return state$jscomp$0.EditorSelection.cursor(forward?range.to:range.from)}function cursorByChar(view,forward){return moveSel(view,range=>range.empty?view.moveByChar(range,forward):rangeEnd(range,forward))}function cursorByGroup(view,forward){return moveSel(view,range=>range.empty?view.moveByGroup(range,forward):rangeEnd(range,forward))}function moveBySyntax(state$1,start,forward){let pos=language.syntaxTree(state$1).resolve(start.head),bracketProp=forward?
lezerTree.NodeProp.closedBy:lezerTree.NodeProp.openedBy;for(start=start.head;;){let next=forward?pos.childAfter(start):pos.childBefore(start);if(!next)break;a:{var JSCompiler_inline_result=state$1;var node=next;if(node.type.prop(bracketProp)){JSCompiler_inline_result=!0;break a}let len=node.to-node.from;JSCompiler_inline_result=len&&(2<len||/[^\s,.;:]/.test(JSCompiler_inline_result.sliceDoc(node.from,node.to)))||node.firstChild}JSCompiler_inline_result?pos=next:start=forward?next.to:next.from}let match;
state$1=pos.type.prop(bracketProp)&&(match=forward?matchbrackets.matchBrackets(state$1,pos.from,1):matchbrackets.matchBrackets(state$1,pos.to,-1))&&match.matched?forward?match.end.to:match.end.from:forward?pos.to:pos.from;return state$jscomp$0.EditorSelection.cursor(state$1,forward?-1:1)}function cursorByLine(view,forward){return moveSel(view,range=>range.empty?view.moveVertically(range,forward):rangeEnd(range,forward))}function cursorByPage(view,forward){return moveSel(view,range=>range.empty?view.moveVertically(range,
forward,view.dom.clientHeight):rangeEnd(range,forward))}function moveByLineBoundary(view,start,forward){let line=view.visualLineAt(start.head),moved=view.moveToLineBoundary(start,forward);moved.head==start.head&&moved.head!=(forward?line.to:line.from)&&(moved=view.moveToLineBoundary(start,forward,!1));!forward&&moved.head==line.from&&line.length&&(view=/^\s*/.exec(view.state.sliceDoc(line.from,Math.min(line.from+100,line.to)))[0].length)&&start.head!=line.from+view&&(moved=state$jscomp$0.EditorSelection.cursor(line.from+
view));return moved}function toMatchingBracket(state$1,dispatch,extend){let found=!1,selection=updateSel(state$1.selection,range=>{var matching=matchbrackets.matchBrackets(state$1,range.head,-1)||matchbrackets.matchBrackets(state$1,range.head,1)||0<range.head&&matchbrackets.matchBrackets(state$1,range.head-1,1)||range.head<state$1.doc.length&&matchbrackets.matchBrackets(state$1,range.head+1,-1);if(!matching||!matching.end)return range;found=!0;matching=matching.start.from==range.head?matching.end.to:
matching.end.from;return extend?state$jscomp$0.EditorSelection.range(range.anchor,matching):state$jscomp$0.EditorSelection.cursor(matching)});if(!found)return!1;dispatch(setSel(state$1,selection));return!0}function extendSel(view,how){let selection=updateSel(view.state.selection,range=>{let head=how(range);return state$jscomp$0.EditorSelection.range(range.anchor,head.head,head.goalColumn)});if(selection.eq(view.state.selection))return!1;view.dispatch(setSel(view.state,selection));return!0}function selectByChar(view,
forward){return extendSel(view,range=>view.moveByChar(range,forward))}function selectByGroup(view,forward){return extendSel(view,range=>view.moveByGroup(range,forward))}function selectByLine(view,forward){return extendSel(view,range=>view.moveVertically(range,forward))}function selectByPage(view,forward){return extendSel(view,range=>view.moveVertically(range,forward,view.dom.clientHeight))}function deleteBy({state:state$1,dispatch},by){let changes=state$1.changeByRange(range=>{let {from,to}=range;
if(from==to){let towards=by(from);from=Math.min(from,towards);to=Math.max(to,towards)}return from==to?{range}:{changes:{from,to},range:state$jscomp$0.EditorSelection.cursor(from)}});if(changes.changes.empty)return!1;dispatch(state$1.update(changes,{scrollIntoView:!0,annotations:state$jscomp$0.Transaction.userEvent.of("delete")}));return!0}function selectedLineBlocks(state){let blocks=[],upto=-1;for(let range of state.selection.ranges){let startLine=state.doc.lineAt(range.from),endLine=state.doc.lineAt(range.to);
upto==startLine.number?blocks[blocks.length-1].to=endLine.to:blocks.push({from:startLine.from,to:endLine.to});upto=endLine.number}return blocks}function moveLine(state,dispatch,forward){let changes=[];for(let block of selectedLineBlocks(state)){if(forward?block.to==state.doc.length:0==block.from)continue;let nextLine=state.doc.lineAt(forward?block.to+1:block.from-1);forward?changes.push({from:block.to,to:nextLine.to},{from:block.from,insert:nextLine.text+state.lineBreak}):changes.push({from:nextLine.from,
to:block.from},{from:block.to,insert:state.lineBreak+nextLine.text})}if(!changes.length)return!1;dispatch(state.update({changes,scrollIntoView:!0}));return!0}function copyLine(state,dispatch,forward){let changes=[];for(let block of selectedLineBlocks(state))forward?changes.push({from:block.from,insert:state.doc.slice(block.from,block.to)+state.lineBreak}):changes.push({from:block.to,insert:state.lineBreak+state.doc.slice(block.from,block.to)});dispatch(state.update({changes,scrollIntoView:!0}));return!0}
function changeBySelectedLine(state$1,f){let atLine=-1;return state$1.changeByRange(range=>{let changes=[];for(var pos=range.from;pos<=range.to;)pos=state$1.doc.lineAt(pos),pos.number>atLine&&(range.empty||range.to>pos.from)&&(f(pos,changes,range),atLine=pos.number),pos=pos.to+1;pos=state$1.changes(changes);return{changes,range:state$jscomp$0.EditorSelection.range(pos.mapPos(range.anchor,1),pos.mapPos(range.head,1))}})}Object.defineProperty(exports,"__esModule",{value:!0});var state$jscomp$0=require("module$node_modules$$codemirror$state$dist$index_cjs"),
text=require("module$node_modules$$codemirror$text$dist$index_cjs"),view$jscomp$0=require("module$node_modules$$codemirror$view$dist$index_cjs"),matchbrackets=require("module$node_modules$$codemirror$matchbrackets$dist$index_cjs"),language=require("module$node_modules$$codemirror$language$dist$index_cjs"),lezerTree=require("module$node_modules$lezer_tree$dist$tree_cjs");global=view$1=>cursorByChar(view$1,view$1.textDirection!=view$jscomp$0.Direction.LTR);require=view$1=>cursorByChar(view$1,view$1.textDirection==
view$jscomp$0.Direction.LTR);module=view$1=>cursorByGroup(view$1,view$1.textDirection!=view$jscomp$0.Direction.LTR);const cursorGroupRight=view$1=>cursorByGroup(view$1,view$1.textDirection==view$jscomp$0.Direction.LTR),cursorGroupForward=view=>cursorByGroup(view,!0),cursorGroupBackward=view=>cursorByGroup(view,!1),cursorSyntaxLeft=view$1=>moveSel(view$1,range=>moveBySyntax(view$1.state,range,view$1.textDirection!=view$jscomp$0.Direction.LTR)),cursorSyntaxRight=view$1=>moveSel(view$1,range=>moveBySyntax(view$1.state,
range,view$1.textDirection==view$jscomp$0.Direction.LTR)),cursorLineUp=view=>cursorByLine(view,!1),cursorLineDown=view=>cursorByLine(view,!0),cursorPageUp=view=>cursorByPage(view,!1),cursorPageDown=view=>cursorByPage(view,!0),cursorLineBoundaryForward=view=>moveSel(view,range=>moveByLineBoundary(view,range,!0)),cursorLineBoundaryBackward=view=>moveSel(view,range=>moveByLineBoundary(view,range,!1)),cursorLineStart=view=>moveSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.visualLineAt(range.head).from,
1)),cursorLineEnd=view=>moveSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.visualLineAt(range.head).to,-1)),cursorMatchingBracket=({state,dispatch})=>toMatchingBracket(state,dispatch,!1),selectCharLeft=view$1=>selectByChar(view$1,view$1.textDirection!=view$jscomp$0.Direction.LTR),selectCharRight=view$1=>selectByChar(view$1,view$1.textDirection==view$jscomp$0.Direction.LTR),selectGroupLeft=view$1=>selectByGroup(view$1,view$1.textDirection!=view$jscomp$0.Direction.LTR),selectGroupRight=
view$1=>selectByGroup(view$1,view$1.textDirection==view$jscomp$0.Direction.LTR),selectGroupForward=view=>selectByGroup(view,!0),selectGroupBackward=view=>selectByGroup(view,!1),selectSyntaxLeft=view$1=>extendSel(view$1,range=>moveBySyntax(view$1.state,range,view$1.textDirection!=view$jscomp$0.Direction.LTR)),selectSyntaxRight=view$1=>extendSel(view$1,range=>moveBySyntax(view$1.state,range,view$1.textDirection==view$jscomp$0.Direction.LTR)),selectLineUp=view=>selectByLine(view,!1),selectLineDown=view=>
selectByLine(view,!0),selectPageUp=view=>selectByPage(view,!1),selectPageDown=view=>selectByPage(view,!0),selectLineBoundaryForward=view=>extendSel(view,range=>moveByLineBoundary(view,range,!0)),selectLineBoundaryBackward=view=>extendSel(view,range=>moveByLineBoundary(view,range,!1)),selectLineStart=view=>extendSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.visualLineAt(range.head).from)),selectLineEnd=view=>extendSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.visualLineAt(range.head).to)),
cursorDocStart=({state,dispatch})=>{dispatch(setSel(state,{anchor:0}));return!0},cursorDocEnd=({state,dispatch})=>{dispatch(setSel(state,{anchor:state.doc.length}));return!0},selectDocStart=({state,dispatch})=>{dispatch(setSel(state,{anchor:state.selection.main.anchor,head:0}));return!0},selectDocEnd=({state,dispatch})=>{dispatch(setSel(state,{anchor:state.selection.main.anchor,head:state.doc.length}));return!0},selectAll=({state:state$1,dispatch})=>{dispatch(state$1.update({selection:{anchor:0,head:state$1.doc.length},
annotations:state$jscomp$0.Transaction.userEvent.of("keyboardselection")}));return!0},selectLine=({state:state$1,dispatch})=>{let ranges=selectedLineBlocks(state$1).map(({from,to})=>state$jscomp$0.EditorSelection.range(from,Math.min(to+1,state$1.doc.length)));dispatch(state$1.update({selection:state$jscomp$0.EditorSelection.create(ranges),annotations:state$jscomp$0.Transaction.userEvent.of("keyboardselection")}));return!0},selectParentSyntax=({state:state$1,dispatch})=>{let selection=updateSel(state$1.selection,
range=>{var _a;let context=language.syntaxTree(state$1).resolve(range.head,1);for(;!(context.from<range.from&&context.to>=range.to||context.to>range.to&&context.from<=range.from)&&(null===(_a=context.parent)||void 0===_a?0:_a.parent);)context=context.parent;return state$jscomp$0.EditorSelection.range(context.to,context.from)});dispatch(setSel(state$1,selection));return!0},simplifySelection=({state:state$1,dispatch})=>{let cur=state$1.selection,selection=null;1<cur.ranges.length?selection=state$jscomp$0.EditorSelection.create([cur.main]):
cur.main.empty||(selection=state$jscomp$0.EditorSelection.create([state$jscomp$0.EditorSelection.cursor(cur.main.head)]));if(!selection)return!1;dispatch(setSel(state$1,selection));return!0},deleteByChar=(target,forward,codePoint)=>deleteBy(target,pos=>{var {state}=target,line=state.doc.lineAt(pos),before;if(!forward&&pos>line.from&&pos<line.from+200&&!/[^ \t]/.test(before=line.text.slice(0,pos-line.from))){if("\t"==before[before.length-1])return pos-1;state=text.countColumn(before,0,state.tabSize)%
language.getIndentUnit(state)||language.getIndentUnit(state);for(line=0;line<state&&" "==before[before.length-1-line];line++)pos--;return pos}codePoint?(before=(before=line.text.slice(pos-line.from+(forward?0:-2),pos-line.from+(forward?2:0)))?text.codePointSize(text.codePointAt(before,0)):1,before=forward?Math.min(state.doc.length,pos+before):Math.max(0,pos-before)):before=text.findClusterBreak(line.text,pos-line.from,forward)+line.from;before==pos&&line.number!=(forward?state.doc.lines:1)&&(before+=
forward?1:-1);return before}),deleteCodePointBackward=view=>deleteByChar(view,!1,!0),deleteCharBackward=view=>deleteByChar(view,!1,!1),deleteCharForward=view=>deleteByChar(view,!0,!1),deleteByGroup=(target,forward)=>deleteBy(target,start=>{let pos=start,{state}=target,line=state.doc.lineAt(pos),categorize=state.charCategorizer(pos);for(let cat=null;;){if(pos==(forward?line.to:line.from)){pos==start&&line.number!=(forward?state.doc.lines:1)&&(pos+=forward?1:-1);break}let next=text.findClusterBreak(line.text,
pos-line.from,forward)+line.from,nextChar=line.text.slice(Math.min(pos,next)-line.from,Math.max(pos,next)-line.from),nextCat=categorize(nextChar);if(null!=cat&&nextCat!=cat)break;if(" "!=nextChar||pos!=start)cat=nextCat;pos=next}return pos}),deleteGroupBackward=target=>deleteByGroup(target,!1),deleteGroupForward=target=>deleteByGroup(target,!0),deleteToLineEnd=view=>deleteBy(view,pos=>{let lineEnd=view.visualLineAt(pos).to;return pos<lineEnd?lineEnd:Math.min(view.state.doc.length,pos+1)}),deleteToLineStart=
view=>deleteBy(view,pos=>{let lineStart=view.visualLineAt(pos).from;return pos>lineStart?lineStart:Math.max(0,pos-1)}),splitLine=({state:state$1,dispatch})=>{let changes=state$1.changeByRange(range=>({changes:{from:range.from,to:range.to,insert:text.Text.of(["",""])},range:state$jscomp$0.EditorSelection.cursor(range.from)}));dispatch(state$1.update(changes,{scrollIntoView:!0,annotations:state$jscomp$0.Transaction.userEvent.of("input")}));return!0},transposeChars=({state:state$1,dispatch})=>{let changes=
state$1.changeByRange(range=>{if(!range.empty||0==range.from||range.from==state$1.doc.length)return{range};range=range.from;var line=state$1.doc.lineAt(range);let from=range==line.from?range-1:text.findClusterBreak(line.text,range-line.from,!1)+line.from;line=range==line.to?range+1:text.findClusterBreak(line.text,range-line.from,!0)+line.from;return{changes:{from,to:line,insert:state$1.doc.slice(range,line).append(state$1.doc.slice(from,range))},range:state$jscomp$0.EditorSelection.cursor(line)}});
if(changes.changes.empty)return!1;dispatch(state$1.update(changes,{scrollIntoView:!0}));return!0},moveLineUp=({state,dispatch})=>moveLine(state,dispatch,!1),moveLineDown=({state,dispatch})=>moveLine(state,dispatch,!0),copyLineUp=({state,dispatch})=>copyLine(state,dispatch,!1),copyLineDown=({state,dispatch})=>copyLine(state,dispatch,!0),deleteLine=view=>{let {state}=view,changes=state.changes(selectedLineBlocks(state).map(({from,to})=>{0<from?from--:to<state.doc.length&&to++;return{from,to}})),selection=
updateSel(state.selection,range=>view.moveVertically(range,!0)).map(changes);view.dispatch({changes,selection,scrollIntoView:!0});return!0},insertNewlineAndIndent=({state:state$1,dispatch})=>{let changes=state$1.changeByRange(({from,to})=>{var JSCompiler_temp;if(JSCompiler_temp=from==to)if(JSCompiler_temp=from,/\(\)|\[\]|\{\}/.test(state$1.sliceDoc(JSCompiler_temp-1,JSCompiler_temp+1)))JSCompiler_temp={from:JSCompiler_temp,to:JSCompiler_temp};else{var context=language.syntaxTree(state$1).resolve(JSCompiler_temp),
before=context.childBefore(JSCompiler_temp);context=context.childAfter(JSCompiler_temp);var closedBy;JSCompiler_temp=before&&context&&before.to<=JSCompiler_temp&&context.from>=JSCompiler_temp&&(closedBy=before.type.prop(lezerTree.NodeProp.closedBy))&&-1<closedBy.indexOf(context.name)&&state$1.doc.lineAt(before.to).from==state$1.doc.lineAt(context.from).from?{from:before.to,to:context.from}:null}closedBy=JSCompiler_temp;JSCompiler_temp=new language.IndentContext(state$1,{simulateBreak:from,simulateDoubleBreak:!!closedBy});
context=language.getIndentation(JSCompiler_temp,from);null==context&&(context=/^\s*/.exec(state$1.doc.lineAt(from).text)[0].length);for(before=state$1.doc.lineAt(from);to<before.to&&/\s/.test(before.text.slice(to-before.from,to+1-before.from));)to++;closedBy?{from,to}=closedBy:from>before.from&&from<before.from+100&&!/\S/.test(before.text.slice(0,from))&&(from=before.from);context=["",language.indentString(state$1,context)];closedBy&&context.push(language.indentString(state$1,JSCompiler_temp.lineIndent(before)));
return{changes:{from,to,insert:text.Text.of(context)},range:state$jscomp$0.EditorSelection.cursor(from+1+context[1].length)}});dispatch(state$1.update(changes,{scrollIntoView:!0}));return!0},indentSelection=({state,dispatch})=>{let updated=Object.create(null),context=new language.IndentContext(state,{overrideIndentation:start=>{start=updated[start];return null==start?-1:start}}),changes$jscomp$0=changeBySelectedLine(state,(line,changes,range)=>{let indent=language.getIndentation(context,line.from);
if(null!=indent){var cur=/^\s*/.exec(line.text)[0],norm=language.indentString(state,indent);if(cur!=norm||range.from<line.from+cur.length)updated[line.from]=indent,changes.push({from:line.from,to:line.from+cur.length,insert:norm})}});changes$jscomp$0.changes.empty||dispatch(state.update(changes$jscomp$0));return!0},indentMore=({state,dispatch})=>{dispatch(state.update(changeBySelectedLine(state,(line,changes)=>{changes.push({from:line.from,insert:state.facet(language.indentUnit)})})));return!0},indentLess=
({state,dispatch})=>{dispatch(state.update(changeBySelectedLine(state,(line,changes)=>{let space=/^\s*/.exec(line.text)[0];if(space){var col=text.countColumn(space,0,state.tabSize),keep=0;for(col=language.indentString(state,Math.max(0,col-language.getIndentUnit(state)));keep<space.length&&keep<col.length&&space.charCodeAt(keep)==col.charCodeAt(keep);)keep++;changes.push({from:line.from+keep,to:line.from+space.length,insert:col.slice(keep)})}})));return!0},insertTab=({state:state$1,dispatch})=>{if(state$1.selection.ranges.some(r=>
!r.empty))return indentMore({state:state$1,dispatch});dispatch(state$1.update(state$1.replaceSelection("\t"),{scrollIntoView:!0,annotations:state$jscomp$0.Transaction.userEvent.of("input")}));return!0},emacsStyleKeymap=[{key:"Ctrl-b",run:global,shift:selectCharLeft,preventDefault:!0},{key:"Ctrl-f",run:require,shift:selectCharRight},{key:"Ctrl-p",run:cursorLineUp,shift:selectLineUp},{key:"Ctrl-n",run:cursorLineDown,shift:selectLineDown},{key:"Ctrl-a",run:cursorLineStart,shift:selectLineStart},{key:"Ctrl-e",
run:cursorLineEnd,shift:selectLineEnd},{key:"Ctrl-d",run:deleteCharForward},{key:"Ctrl-h",run:deleteCharBackward},{key:"Ctrl-k",run:deleteToLineEnd},{key:"Alt-d",run:deleteGroupForward},{key:"Ctrl-Alt-h",run:deleteGroupBackward},{key:"Ctrl-o",run:splitLine},{key:"Ctrl-t",run:transposeChars},{key:"Alt-f",run:cursorGroupForward,shift:selectGroupForward},{key:"Alt-b",run:cursorGroupBackward,shift:selectGroupBackward},{key:"Alt-\x3c",run:cursorDocStart},{key:"Alt-\x3e",run:cursorDocEnd},{key:"Ctrl-v",
run:cursorPageDown},{key:"Alt-v",run:cursorPageUp}],standardKeymap=[{key:"ArrowLeft",run:global,shift:selectCharLeft},{key:"Mod-ArrowLeft",mac:"Alt-ArrowLeft",run:module,shift:selectGroupLeft},{mac:"Cmd-ArrowLeft",run:cursorLineBoundaryBackward,shift:selectLineBoundaryBackward},{key:"ArrowRight",run:require,shift:selectCharRight},{key:"Mod-ArrowRight",mac:"Alt-ArrowRight",run:cursorGroupRight,shift:selectGroupRight},{mac:"Cmd-ArrowRight",run:cursorLineBoundaryForward,shift:selectLineBoundaryForward},
{key:"ArrowUp",run:cursorLineUp,shift:selectLineUp},{mac:"Cmd-ArrowUp",run:cursorDocStart,shift:selectDocStart},{mac:"Ctrl-ArrowUp",run:cursorPageUp,shift:selectPageUp},{key:"ArrowDown",run:cursorLineDown,shift:selectLineDown},{mac:"Cmd-ArrowDown",run:cursorDocEnd,shift:selectDocEnd},{mac:"Ctrl-ArrowDown",run:cursorPageDown,shift:selectPageDown},{key:"PageUp",run:cursorPageUp,shift:selectPageUp},{key:"PageDown",run:cursorPageDown,shift:selectPageDown},{key:"Home",run:cursorLineBoundaryBackward,shift:selectLineBoundaryBackward},
{key:"Mod-Home",run:cursorDocStart,shift:selectDocStart},{key:"End",run:cursorLineBoundaryForward,shift:selectLineBoundaryForward},{key:"Mod-End",run:cursorDocEnd,shift:selectDocEnd},{key:"Enter",run:insertNewlineAndIndent},{key:"Mod-a",run:selectAll},{key:"Backspace",run:deleteCodePointBackward,shift:deleteCodePointBackward},{key:"Delete",run:deleteCharForward,shift:deleteCharForward},{key:"Mod-Backspace",mac:"Alt-Backspace",run:deleteGroupBackward},{key:"Mod-Delete",mac:"Alt-Delete",run:deleteGroupForward},
{mac:"Mod-Backspace",run:deleteToLineStart},{mac:"Mod-Delete",run:deleteToLineEnd}].concat(emacsStyleKeymap.map(b=>({mac:b.key,run:b.run,shift:b.shift}))),defaultKeymap=[{key:"Alt-ArrowLeft",mac:"Ctrl-ArrowLeft",run:cursorSyntaxLeft,shift:selectSyntaxLeft},{key:"Alt-ArrowRight",mac:"Ctrl-ArrowRight",run:cursorSyntaxRight,shift:selectSyntaxRight},{key:"Alt-ArrowUp",run:moveLineUp},{key:"Shift-Alt-ArrowUp",run:copyLineUp},{key:"Alt-ArrowDown",run:moveLineDown},{key:"Shift-Alt-ArrowDown",run:copyLineDown},
{key:"Escape",run:simplifySelection},{key:"Alt-l",mac:"Ctrl-l",run:selectLine},{key:"Mod-i",run:selectParentSyntax,preventDefault:!0},{key:"Mod-[",run:indentLess},{key:"Mod-]",run:indentMore},{key:"Mod-Alt-\\",run:indentSelection},{key:"Shift-Mod-k",run:deleteLine},{key:"Shift-Mod-\\",run:cursorMatchingBracket}].concat(standardKeymap),defaultTabBinding={key:"Tab",run:insertTab,shift:indentSelection};exports.copyLineDown=copyLineDown;exports.copyLineUp=copyLineUp;exports.cursorCharBackward=view=>cursorByChar(view,
!1);exports.cursorCharForward=view=>cursorByChar(view,!0);exports.cursorCharLeft=global;exports.cursorCharRight=require;exports.cursorDocEnd=cursorDocEnd;exports.cursorDocStart=cursorDocStart;exports.cursorGroupBackward=cursorGroupBackward;exports.cursorGroupForward=cursorGroupForward;exports.cursorGroupLeft=module;exports.cursorGroupRight=cursorGroupRight;exports.cursorLineBoundaryBackward=cursorLineBoundaryBackward;exports.cursorLineBoundaryForward=cursorLineBoundaryForward;exports.cursorLineDown=
cursorLineDown;exports.cursorLineEnd=cursorLineEnd;exports.cursorLineStart=cursorLineStart;exports.cursorLineUp=cursorLineUp;exports.cursorMatchingBracket=cursorMatchingBracket;exports.cursorPageDown=cursorPageDown;exports.cursorPageUp=cursorPageUp;exports.cursorSyntaxLeft=cursorSyntaxLeft;exports.cursorSyntaxRight=cursorSyntaxRight;exports.defaultKeymap=defaultKeymap;exports.defaultTabBinding=defaultTabBinding;exports.deleteCharBackward=deleteCharBackward;exports.deleteCharForward=deleteCharForward;
exports.deleteCodePointBackward=deleteCodePointBackward;exports.deleteCodePointForward=view=>deleteByChar(view,!0,!0);exports.deleteGroupBackward=deleteGroupBackward;exports.deleteGroupForward=deleteGroupForward;exports.deleteLine=deleteLine;exports.deleteToLineEnd=deleteToLineEnd;exports.deleteToLineStart=deleteToLineStart;exports.deleteTrailingWhitespace=({state,dispatch})=>{let changes=[];for(let pos=0,prev="",iter=state.doc.iter();;){iter.next();if(iter.lineBreak||iter.done){let trailing=prev.search(/\s+$/);
-1<trailing&&changes.push({from:pos-(prev.length-trailing),to:pos});if(iter.done)break;prev=""}else prev=iter.value;pos+=iter.value.length}if(!changes.length)return!1;dispatch(state.update({changes}));return!0};exports.emacsStyleKeymap=emacsStyleKeymap;exports.indentLess=indentLess;exports.indentMore=indentMore;exports.indentSelection=indentSelection;exports.insertNewline=({state,dispatch})=>{dispatch(state.update(state.replaceSelection(state.lineBreak),{scrollIntoView:!0}));return!0};exports.insertNewlineAndIndent=
insertNewlineAndIndent;exports.insertTab=insertTab;exports.moveLineDown=moveLineDown;exports.moveLineUp=moveLineUp;exports.selectAll=selectAll;exports.selectCharBackward=view=>selectByChar(view,!1);exports.selectCharForward=view=>selectByChar(view,!0);exports.selectCharLeft=selectCharLeft;exports.selectCharRight=selectCharRight;exports.selectDocEnd=selectDocEnd;exports.selectDocStart=selectDocStart;exports.selectGroupBackward=selectGroupBackward;exports.selectGroupForward=selectGroupForward;exports.selectGroupLeft=
selectGroupLeft;exports.selectGroupRight=selectGroupRight;exports.selectLine=selectLine;exports.selectLineBoundaryBackward=selectLineBoundaryBackward;exports.selectLineBoundaryForward=selectLineBoundaryForward;exports.selectLineDown=selectLineDown;exports.selectLineEnd=selectLineEnd;exports.selectLineStart=selectLineStart;exports.selectLineUp=selectLineUp;exports.selectMatchingBracket=({state,dispatch})=>toMatchingBracket(state,dispatch,!0);exports.selectPageDown=selectPageDown;exports.selectPageUp=
selectPageUp;exports.selectParentSyntax=selectParentSyntax;exports.selectSyntaxLeft=selectSyntaxLeft;exports.selectSyntaxRight=selectSyntaxRight;exports.simplifySelection=simplifySelection;exports.splitLine=splitLine;exports.standardKeymap=standardKeymap;exports.transposeChars=transposeChars}
//# sourceMappingURL=module$node_modules$$codemirror$commands$dist$index_cjs.js.map
