{
"version":3,
"file":"module$node_modules$$codemirror$rangeset$dist$index_cjs.js",
"lineCount":31,
"mappings":"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",
"sources":["node_modules/@codemirror/rangeset/dist/index.cjs"],
"sourcesContent":["shadow$provide[\"module$node_modules$$codemirror$rangeset$dist$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar state = require('@codemirror/state');\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n    /**\n    Compare this value with another value. The default\n    implementation compares by identity.\n    */\n    eq(other) { return this == other; }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n    */\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = state.MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The range's start position.\n    */\n    from, \n    /**\n    Its end position.\n    */\n    to, \n    /**\n    The value associated with this range.\n    */\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // With side == -1, return the first index where to >= pos. When\n    // side == 1, the first index where from > pos.\n    findIndex(pos, end, side = end * 1000000000 /* Far */, startAt = 0) {\n        if (pos <= 0)\n            return startAt;\n        let arr = end < 0 ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    chunkPos, \n    /**\n    @internal\n    */\n    chunk, \n    /**\n    @internal\n    */\n    nextLayer = RangeSet.empty, \n    /**\n    @internal\n    */\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n    get size() {\n        if (this == RangeSet.empty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (The extra type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add.slice().sort(cmpRange);\n        if (this == RangeSet.empty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n    map(changes) {\n        if (changes.length == 0 || this == RangeSet.empty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n    between(from, to, f) {\n        if (this == RangeSet.empty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n    static compare(oldSets, newSets, \n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration. `from` and\n    `to` are coordinates in the _new_ space, after these changes.\n    */\n    textDiff, comparator, \n    /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n    of the iteration.\n    */\n    static spans(sets, from, to, iterator, \n    /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */\n    minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let open = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, open);\n                open = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n        return open;\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = new RangeSet([], [], null, -1);\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\nclass RangeSetBuilder {\n    /**\n    Create an empty builder.\n    */\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* Far */;\n        this.lastTo = -1000000000 /* Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n    finish() { return this.finishInner(RangeSet.empty); }\n    /**\n    @internal\n    */\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint < 500 /* BigPointSize */)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (inA.get(set.chunk[i]) == set.chunkPos[i])\n                shared.add(set.chunk[i]);\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0\n            : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);\n        if (!forward || this.rangeIndex < rangeIndex)\n            this.rangeIndex = rangeIndex;\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                if (++this.rangeIndex == chunk.value.length) {\n                    this.chunkIndex++;\n                    if (this.skip) {\n                        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                            this.chunkIndex++;\n                    }\n                    this.rangeIndex = 0;\n                }\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; cur != RangeSet.empty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* Far */;\n        this.endSide = 0;\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to && nextVal.endSide == this.endSide) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    if (this.cursor.from < from)\n                        trackExtra = 1;\n                    this.cursor.next();\n                    if (this.to > from)\n                        this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            let openStart = 0;\n            while (openStart < trackOpen.length && trackOpen[openStart] < from)\n                openStart++;\n            this.openStart = openStart + trackExtra;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = 0; i < this.active.length; i++) {\n            if (this.activeRank[i] > this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active;\n    }\n    openEnd(to) {\n        let open = 0;\n        while (open < this.activeTo.length && this.activeTo[open] > to)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\nexports.Range = Range;\nexports.RangeSet = RangeSet;\nexports.RangeSetBuilder = RangeSetBuilder;\nexports.RangeValue = RangeValue;\n\n};"],
"names":["shadow$provide","global","require","module","exports","cmpRange","a","b","from","value","startSide","findSharedChunks","inA","Map","set","i","chunk","length","maxPoint","chunkPos","shared","Set","get","add","heapBubble","heap","index","cur","childIndex","child","compare","startA","startB","comparator","goto","endB","pos","dPos","diff","to","endSide","end","clipEnd","Math","min","point","eq","comparePoint","compareRange","active","next","remove","array","e","pop","insert","findMinIndex","found","foundPos","Object","defineProperty","state","RangeValue","other","range","Range","prototype","mapMode","MapMode","TrackDel","constructor","Chunk","findIndex","side","startAt","arr","lo","hi","mid","between","offset","f","undefined","map","changes","newPos","val","curFrom","curTo","mapped","mapPos","newFrom","newTo","max","push","RangeSet","nextLayer","empty","last","chunkEnd","size","update","updateSpec","sort","filterFrom","filterTo","filter","slice","of","LayerCursor","spill","builder","RangeSetBuilder","addInner","rangeIndex","chunkIndex","addChunk","nextChunk","finishInner","chunks","start","touch","touchesRange","iter","HeapCursor","sets","oldSets","newSets","textDiff","minPointSize","indexOf","sharedChunks","sideA","SpanCursor","sideB","iterGaps","fromA","fromB","spans","iterator","cursor","open","openStart","activeForPoint","openEnd","span","ranges","build","finish","chunkStart","lastTo","lastFrom","setMaxPoint","finishChunk","newArrays","Error","result","layer","skip","minPoint","rank","gotoInner","forward","has","top","activeTo","activeRank","minActive","pointRank","pointFrom","removeActive","addActive","trackOpen","wasPoint","trackExtra","nextVal"]
}
