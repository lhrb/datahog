shadow$provide.module$node_modules$$codemirror$language$dist$index_cjs=function(global,require,module,exports){function defineLanguageFacet(baseData){return state$jscomp$0.Facet.define({combine:baseData?values=>values.concat(baseData):void 0})}function languageDataFacetAt(state,pos){let topLang=state.facet(language);if(!topLang)return null;if(!topLang.allowsNesting)return topLang.data;for(state=syntaxTree(state).resolve(pos,-1);state;){if(pos=state.type.prop(languageDataProp))return pos;state=state.parent}return topLang.data}
function syntaxTree(state){return(state=state.field(Language.state,!1))?state.tree:lezerTree.Tree.empty}function cutFragments(fragments,from,to){return lezerTree.TreeFragment.applyChanges(fragments,[{fromA:from,toA:to,fromB:from,toB:to}])}function getIndentUnit(state){let unit=state.facet(indentUnit);return 9==unit.charCodeAt(0)?state.tabSize*unit.length:unit.length}function indentString(state,cols){let result="",ts=state.tabSize;if(9==state.facet(indentUnit).charCodeAt(0))for(;cols>=ts;)result+=
"\t",cols-=ts;for(state=0;state<cols;state++)result+=" ";return result}function getIndentation(context,pos){context instanceof state$jscomp$0.EditorState&&(context=new IndentContext(context));for(var service of context.state.facet(indentService)){var result=service(context,pos);if(null!=result)return result}if(service=syntaxTree(context.state)){service=service.resolve(pos);for(let scan=service,scanPos=pos;;){result=scan.childBefore(scanPos);if(!result)break;result.type.isError&&result.from==result.to?
(service=scan,scanPos=result.from):(scan=result,scanPos=scan.to+1)}pos=indentFrom(service,pos,context)}else pos=null;return pos}function indentStrategy(tree){var strategy=tree.type.prop(indentNodeProp);if(strategy)return strategy;strategy=tree.firstChild;let close;if(strategy&&(close=strategy.type.prop(lezerTree.NodeProp.closedBy))){let last=tree.lastChild,closed=last&&-1<close.indexOf(last.name);return cx=>{var JSCompiler_temp;if(JSCompiler_temp=closed){var _a,_b;JSCompiler_temp=!(cx.pos==(null===
(_a=cx.options)||void 0===_a?void 0:_a.simulateBreak)&&(null===(_b=cx.options)||void 0===_b?0:_b.simulateDoubleBreak))}return delimitedStrategy(cx,!0,1,void 0,JSCompiler_temp?last.from:void 0)}}return null==tree.parent?topIndent:null}function indentFrom(node,pos,base){for(;node;node=node.parent){let strategy=indentStrategy(node);if(strategy)return strategy(new TreeIndentContext(base,pos,node))}return null}function topIndent(){return 0}function delimitedStrategy(context,align,units,closing,closedAt){var after=
context.textAfter,space=after.match(/^\s*/)[0].length;closing=closing&&after.slice(space,space+closing.length)==closing||closedAt==context.pos+space;var JSCompiler_temp;if(align)a:if(align=context.node,closedAt=align.childAfter(align.from),after=align.lastChild,closedAt)for(space=null===(JSCompiler_temp=context.options)||void 0===JSCompiler_temp?void 0:JSCompiler_temp.simulateBreak,JSCompiler_temp=context.state.doc.lineAt(closedAt.from),JSCompiler_temp=null==space||space<=JSCompiler_temp.from?JSCompiler_temp.to:
Math.min(JSCompiler_temp.to,space),space=closedAt.to;;){space=align.childAfter(space);if(!space||space==after){JSCompiler_temp=null;break a}if(!space.type.isSkipped){JSCompiler_temp=space.from<JSCompiler_temp?closedAt:null;break a}space=space.to}else JSCompiler_temp=null;else JSCompiler_temp=null;return JSCompiler_temp?closing?context.column(JSCompiler_temp.from):context.column(JSCompiler_temp.to):context.baseIndent+(closing?0:context.unit*units)}Object.defineProperty(exports,"__esModule",{value:!0});
var lezerTree=require("module$node_modules$lezer_tree$dist$tree_cjs"),text$jscomp$0=require("module$node_modules$$codemirror$text$dist$index_cjs"),state$jscomp$0=require("module$node_modules$$codemirror$state$dist$index_cjs");global=require("module$node_modules$$codemirror$view$dist$index_cjs");const languageDataProp=new lezerTree.NodeProp;class Language{constructor(data,parser,topNode,extraExtensions=[]){this.data=data;this.topNode=topNode;state$jscomp$0.EditorState.prototype.hasOwnProperty("tree")||
Object.defineProperty(state$jscomp$0.EditorState.prototype,"tree",{get(){return syntaxTree(this)}});this.parser=parser;this.extension=[language.of(this),state$jscomp$0.EditorState.languageData.of((state,pos)=>state.facet(languageDataFacetAt(state,pos)))].concat(extraExtensions)}isActiveAt(state,pos){return languageDataFacetAt(state,pos)==this.data}findRegions(state){let lang=state.facet(language);if((null===lang||void 0===lang?void 0:lang.data)==this.data)return[{from:0,to:state.doc.length}];if(!lang||
!lang.allowsNesting)return[];let result=[];syntaxTree(state).iterate({enter:(type,from,to)=>{if(type.isTop&&type.prop(languageDataProp)==this.data)return result.push({from,to}),!1}});return result}get allowsNesting(){return!0}parseString(code){var doc=text$jscomp$0.Text.of(code.split("\n"));for(code=this.parser.startParse(new DocInput(doc),0,new EditorParseContext(this.parser,state$jscomp$0.EditorState.create({doc}),[],lezerTree.Tree.empty,{from:0,to:code.length},[],null));!(doc=code.advance()););
return doc}}Language.setState=state$jscomp$0.StateEffect.define();class LezerLanguage extends Language{constructor(data,parser){super(data,parser,parser.topNode);this.parser=parser}static define(spec){let data=defineLanguageFacet(spec.languageData);return new LezerLanguage(data,spec.parser.configure({props:[languageDataProp.add(type=>type.isTop?data:void 0)]}))}configure(options){return new LezerLanguage(this.data,this.parser.configure(options))}get allowsNesting(){return this.parser.hasNested}}class DocInput{constructor(doc,
length=doc.length){this.doc=doc;this.length=length;this.cursorPos=0;this.prevString=this.string="";this.cursor=doc.iter()}syncTo(pos){pos<this.cursorPos&&(this.cursor=this.doc.iter(),this.cursorPos=0);this.prevString=pos==this.cursorPos?this.string:"";this.string=this.cursor.next(pos-this.cursorPos).value;this.cursorPos=pos+this.string.length;return this.cursorPos-this.string.length}get(pos){if(pos>=this.length)return-1;let stringStart=this.cursorPos-this.string.length;if(pos<stringStart||pos>=this.cursorPos){if(pos<
stringStart&&pos>=stringStart-this.prevString.length)return this.prevString.charCodeAt(pos-(stringStart-this.prevString.length));stringStart=this.syncTo(pos)}return this.string.charCodeAt(pos-stringStart)}lineAfter(pos){if(pos>=this.length||0>pos)return"";let stringStart=this.cursorPos-this.string.length;if(pos<stringStart||pos>=this.cursorPos)stringStart=this.syncTo(pos);return this.cursor.lineBreak?"":this.string.slice(pos-stringStart,Math.min(this.length-stringStart,this.string.length))}read(from,
to){let stringStart=this.cursorPos-this.string.length;return from<stringStart||to>=this.cursorPos?this.doc.sliceString(from,to):this.string.slice(from-stringStart,to-stringStart)}clip(at){return new DocInput(this.doc,at)}}class EditorParseContext{constructor(parser,state,fragments=[],tree,viewport,skipped,scheduleOn){this.parser=parser;this.state=state;this.fragments=fragments;this.tree=tree;this.viewport=viewport;this.skipped=skipped;this.scheduleOn=scheduleOn;this.parse=null;this.tempSkipped=[]}work(time,
upto){if(this.tree!=lezerTree.Tree.empty&&(null==upto?this.tree.length==this.state.doc.length:this.tree.length>=upto))return this.takeTree(),!0;this.parse||(this.parse=this.parser.startParse(new DocInput(this.state.doc),0,this));for(time=Date.now()+time;;){let done=this.parse.advance();if(done)return this.fragments=this.withoutTempSkipped(lezerTree.TreeFragment.addTree(done)),this.parse=null,this.tree=done,!0;if(null!=upto&&this.parse.pos>=upto)return this.takeTree(),!0;if(Date.now()>time)return!1}}takeTree(){this.parse&&
this.parse.pos>this.tree.length&&(this.tree=this.parse.forceFinish(),this.fragments=this.withoutTempSkipped(lezerTree.TreeFragment.addTree(this.tree,this.fragments,!0)))}withoutTempSkipped(fragments){for(let r;r=this.tempSkipped.pop();)fragments=cutFragments(fragments,r.from,r.to);return fragments}changes(changes,newState){let {fragments,tree,viewport,skipped}=this;this.takeTree();if(!changes.empty){let ranges=[];changes.iterChangedRanges((fromA,toA,fromB,toB)=>ranges.push({fromA,toA,fromB,toB}));
fragments=lezerTree.TreeFragment.applyChanges(fragments,ranges);tree=lezerTree.Tree.empty;viewport={from:changes.mapPos(viewport.from,-1),to:changes.mapPos(viewport.to,1)};if(this.skipped.length){skipped=[];for(let r of this.skipped){let from=changes.mapPos(r.from,1),to=changes.mapPos(r.to,-1);from<to&&skipped.push({from,to})}}}return new EditorParseContext(this.parser,newState,fragments,tree,viewport,skipped,this.scheduleOn)}updateViewport(viewport){this.viewport=viewport;let startLen=this.skipped.length;
for(let i=0;i<this.skipped.length;i++){let {from,to}=this.skipped[i];from<viewport.to&&to>viewport.from&&(this.fragments=cutFragments(this.fragments,from,to),this.skipped.splice(i--,1))}return this.skipped.length<startLen}reset(){this.parse&&(this.takeTree(),this.parse=null)}skipUntilInView(from,to){this.skipped.push({from,to})}static getSkippingParser(until){return{startParse(input,startPos,context){return{pos:startPos,advance(){context.tempSkipped.push({from:startPos,to:input.length});until&&(context.scheduleOn=
context.scheduleOn?Promise.all([context.scheduleOn,until]):until);this.pos=input.length;return new lezerTree.Tree(lezerTree.NodeType.none,[],[],input.length-startPos)},forceFinish(){return this.advance()}}}}}movedPast(pos){return this.tree.length<pos&&this.parse&&this.parse.pos>=pos}}EditorParseContext.skippingParser=EditorParseContext.getSkippingParser();class LanguageState{constructor(context){this.context=context;this.tree=context.tree}apply(tr){if(!tr.docChanged)return this;let newCx=this.context.changes(tr.changes,
tr.state);tr=this.context.tree.length==tr.startState.doc.length?void 0:Math.max(tr.changes.mapPos(this.context.tree.length),newCx.viewport.to);newCx.work(25,tr)||newCx.takeTree();return new LanguageState(newCx)}static init(state){state=new EditorParseContext(state.facet(language).parser,state,[],lezerTree.Tree.empty,{from:0,to:state.doc.length},[],null);state.work(25)||state.takeTree();return new LanguageState(state)}}Language.state=state$jscomp$0.StateField.define({create:LanguageState.init,update(value,
tr){for(let e of tr.effects)if(e.is(Language.setState))return e.value;return tr.startState.facet(language)!=tr.state.facet(language)?LanguageState.init(tr.state):value.apply(tr)}});let requestIdle="undefined"!=typeof window&&window.requestIdleCallback||((callback,{timeout})=>setTimeout(callback,timeout)),cancelIdle="undefined"!=typeof window&&window.cancelIdleCallback||clearTimeout;global=global.ViewPlugin.fromClass(class{constructor(view){this.view=view;this.chunkBudget=this.chunkEnd=this.working=
-1;this.work=this.work.bind(this);this.scheduleWork()}update(update){let cx=this.view.state.field(Language.state).context;update.viewportChanged&&(cx.updateViewport(update.view.viewport)&&cx.reset(),this.view.viewport.to>cx.tree.length&&this.scheduleWork());update.docChanged&&(this.view.hasFocus&&(this.chunkBudget+=50),this.scheduleWork());this.checkAsyncSchedule(cx)}scheduleWork(force=!1){if(!(-1<this.working)){var {state}=this.view,field=state.field(Language.state);!force&&field.tree.length>=state.doc.length||
(this.working=requestIdle(this.work,{timeout:500}))}}work(deadline){this.working=-1;let now=Date.now();this.chunkEnd<now&&(0>this.chunkEnd||this.view.hasFocus)&&(this.chunkEnd=now+3E4,this.chunkBudget=3E3);if(!(0>=this.chunkBudget)){var {state,viewport:{to:vpTo}}=this.view,field=state.field(Language.state);if(!(field.tree.length>=vpTo+1E6)){deadline=Math.min(this.chunkBudget,deadline?Math.max(25,deadline.timeRemaining()):100);deadline=field.context.work(deadline,vpTo+1E6);this.chunkBudget-=Date.now()-
now;if(deadline||0>=this.chunkBudget||field.context.movedPast(vpTo))field.context.takeTree(),this.view.dispatch({effects:Language.setState.of(new LanguageState(field.context))});!deadline&&0<this.chunkBudget&&this.scheduleWork();this.checkAsyncSchedule(field.context)}}}checkAsyncSchedule(cx){cx.scheduleOn&&(cx.scheduleOn.then(()=>this.scheduleWork(!0)),cx.scheduleOn=null)}destroy(){0<=this.working&&cancelIdle(this.working)}},{eventHandlers:{focus(){this.scheduleWork()}}});const language=state$jscomp$0.Facet.define({combine(languages){return languages.length?
languages[0]:null},enables:[Language.state,global]});class LanguageSupport{constructor(language,support=[]){this.language=language;this.support=support;this.extension=[language,support]}}class LanguageDescription{constructor(name,alias,extensions,filename,loadFunc){this.name=name;this.alias=alias;this.extensions=extensions;this.filename=filename;this.loadFunc=loadFunc;this.support=void 0;this.loading=null}load(){return this.loading||(this.loading=this.loadFunc().then(support=>this.support=support,
err=>{this.loading=null;throw err;}))}static of(spec){return new LanguageDescription(spec.name,(spec.alias||[]).concat(spec.name).map(s=>s.toLowerCase()),spec.extensions||[],spec.filename,spec.load)}static matchFilename(descs,filename){for(let d of descs)if(d.filename&&d.filename.test(filename))return d;if(filename=/\.([^.]+)$/.exec(filename))for(let d of descs)if(-1<d.extensions.indexOf(filename[1]))return d;return null}static matchLanguageName(descs,name,fuzzy=!0){name=name.toLowerCase();for(let d of descs)if(d.alias.some(a=>
a==name))return d;if(fuzzy)for(let d of descs)for(let a of d.alias)if(descs=name.indexOf(a),-1<descs&&(2<a.length||!/\w/.test(name[descs-1])&&!/\w/.test(name[descs+a.length])))return d;return null}}const indentService=state$jscomp$0.Facet.define(),indentUnit=state$jscomp$0.Facet.define({combine:values=>{if(!values.length)return"  ";if(!/^(?: +|\t+)$/.test(values[0]))throw Error("Invalid indent unit: "+JSON.stringify(values[0]));return values[0]}});class IndentContext{constructor(state,options={}){this.state=
state;this.options=options;this.unit=getIndentUnit(state)}textAfterPos(pos){var _a,_b;let sim=null===(_a=this.options)||void 0===_a?void 0:_a.simulateBreak;return pos==sim&&(null===(_b=this.options)||void 0===_b?0:_b.simulateDoubleBreak)?"":this.state.sliceDoc(pos,Math.min(pos+100,null!=sim&&sim>pos?sim:1E9,this.state.doc.lineAt(pos).to))}column(pos){var _a,line=this.state.doc.lineAt(pos);let text=line.text.slice(0,pos-line.from);pos=this.countColumn(text,pos-line.from);line=(null===(_a=this.options)||
void 0===_a?0:_a.overrideIndentation)?this.options.overrideIndentation(line.from):-1;-1<line&&(pos+=line-this.countColumn(text,text.search(/\S/)));return pos}countColumn(line,pos){return text$jscomp$0.countColumn(0>pos?line:line.slice(0,pos),0,this.state.tabSize)}lineIndent(line){var _a;let override=null===(_a=this.options)||void 0===_a?void 0:_a.overrideIndentation;return override&&(_a=override(line.from),-1<_a)?_a:this.countColumn(line.text,line.text.search(/\S/))}}const indentNodeProp=new lezerTree.NodeProp;
class TreeIndentContext extends IndentContext{constructor(base,pos,node){super(base.state,base.options);this.base=base;this.pos=pos;this.node=node}get textAfter(){return this.textAfterPos(this.pos)}get baseIndent(){let line=this.state.doc.lineAt(this.node.from);for(;;){let atBreak=this.node.resolve(line.from);for(;atBreak.parent&&atBreak.parent.from==atBreak.from;)atBreak=atBreak.parent;var JSCompiler_inline_result;a:{for(JSCompiler_inline_result=this.node;JSCompiler_inline_result;JSCompiler_inline_result=
JSCompiler_inline_result.parent)if(atBreak==JSCompiler_inline_result){JSCompiler_inline_result=!0;break a}JSCompiler_inline_result=!1}if(JSCompiler_inline_result)break;line=this.state.doc.lineAt(atBreak.from)}return this.lineIndent(line)}continue(){let parent=this.node.parent;return parent?indentFrom(parent,this.pos,this.base):0}}const foldService=state$jscomp$0.Facet.define(),foldNodeProp=new lezerTree.NodeProp;exports.EditorParseContext=EditorParseContext;exports.IndentContext=IndentContext;exports.Language=
Language;exports.LanguageDescription=LanguageDescription;exports.LanguageSupport=LanguageSupport;exports.LezerLanguage=LezerLanguage;exports.TreeIndentContext=TreeIndentContext;exports.continuedIndent=function({except,units=1}={}){return context=>{let matchExcept=except&&except.test(context.textAfter);return context.baseIndent+(matchExcept?0:units*context.unit)}};exports.defineLanguageFacet=defineLanguageFacet;exports.delimitedIndent=function({closing,align=!0,units=1}){return context=>delimitedStrategy(context,
align,units,closing)};exports.ensureSyntaxTree=function(state,upto,timeout=50){var _a;return(state=null===(_a=state.field(Language.state,!1))||void 0===_a?void 0:_a.context)?state.tree.length>=upto||state.work(timeout,upto)?state.tree:null:null};exports.flatIndent=context=>context.baseIndent;exports.foldInside=function(node){let first=node.firstChild,last=node.lastChild;return first&&first.to<last.from?{from:first.to,to:last.type.isError?node.to:last.from}:null};exports.foldNodeProp=foldNodeProp;
exports.foldService=foldService;exports.foldable=function(state,lineStart,lineEnd){for(var service of state.facet(foldService)){var result=service(state,lineStart,lineEnd);if(result)return result}service=syntaxTree(state);if(0==service.length)state=null;else{result=service.resolve(lineEnd);for(service=null;result;result=result.parent)if(!(result.to<=lineEnd||result.from>lineEnd)){if(service&&result.from<lineStart)break;var prop=result.type.prop(foldNodeProp);prop&&(prop=prop(result,state))&&prop.from<=
lineEnd&&prop.from>=lineStart&&prop.to>lineEnd&&(service=prop)}state=service}return state};exports.getIndentUnit=getIndentUnit;exports.getIndentation=getIndentation;exports.indentNodeProp=indentNodeProp;exports.indentOnInput=function(){return state$jscomp$0.EditorState.transactionFilter.of(tr=>{if(!tr.docChanged||"input"!=tr.annotation(state$jscomp$0.Transaction.userEvent))return tr;var rules=tr.startState.languageDataAt("indentOnInput",tr.startState.selection.main.head);if(!rules.length)return tr;
var doc=tr.newDoc,{head:head$jscomp$0}=tr.newSelection.main,line=doc.lineAt(head$jscomp$0);if(head$jscomp$0>line.from+200)return tr;let lineStart=doc.sliceString(line.from,head$jscomp$0);if(!rules.some(r=>r.test(lineStart)))return tr;({state:rules}=tr);doc=-1;head$jscomp$0=[];for(let {head}of rules.selection.ranges){line=rules.doc.lineAt(head);if(line.from==doc)continue;doc=line.from;var indent=getIndentation(rules,line.from);if(null==indent)continue;let cur=/^\s*/.exec(line.text)[0];indent=indentString(rules,
indent);cur!=indent&&head$jscomp$0.push({from:line.from,to:line.from+cur.length,insert:indent})}return head$jscomp$0.length?[tr,{changes:head$jscomp$0}]:tr})};exports.indentService=indentService;exports.indentString=indentString;exports.indentUnit=indentUnit;exports.language=language;exports.languageDataProp=languageDataProp;exports.syntaxTree=syntaxTree}
//# sourceMappingURL=module$node_modules$$codemirror$language$dist$index_cjs.js.map
