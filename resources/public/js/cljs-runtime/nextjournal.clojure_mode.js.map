{"version":3,"sources":["nextjournal/clojure_mode.cljs"],"mappings":";;;;;;;;AAqBA,AAAKA,2CACH,iBAAMC,YAAU,WAASC;AAAT,AAAA,iBAAyB,6CAAA,5CAAK,AAACC,oCAAQD,oBAChB,2CAAA,1CAAK,AAACE,kCAAMF;;AADnD,AAEE,kBACUD,gBACHA,iBACCA;;AAGZ,AAAKI,sCACH,qBAAA,wCAAA,mEAAA,WAAA,iBAAA,gBAAA,yDAAA,2DAAA,yDAAA,wDAAA,uEAAA,kBAAA,8DAAA,0DAAA,lmBAACC,o+CAAkB,AAAWC,5IACF,AAAWA,jjBACZ,AAAaA,yEAAK,AAAgBA,mJAC1C,AAAQA,vEACD,AAAYA,keAClB,AAAWA,rRACb,AAAUA,0IACH,AAAUA,jjBAGd,AAAUA,oWACZ,AAAQA,oeACZ,AAAQA,l5BACA,AAAeA,sjBACpB,AAAUA;AAE9B,AAAKC,kCAAOC;AAEZ,AAQA,AAAA,kCAAA,0CAAAC,5EAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC;;;KAAA;AAAA,OAAAA,8DAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,gEAAA,hEAAMD;AAAN,AAEG,OAACE,8DAAON;;;AAFX,CAAA,gEAAA,hEAAMI,2EAGEG;AAHR,AAIG,oFAAA,7EAASC,yFACa,iBAAA,WAAA,5BAAYD,6BAAwBE,qDACA,AAAMC,yEAAsBlB,0CAC5B,AAACmB,mEAAoBd,2CACtE,iBAAA,kBAAA,SAAA;;;AARZ,CAAA,0DAAA,1DAAMO;;AAAN,AAYA,AAAeQ,2CAAgBC;AAC/B,AAAeC,0CAAeC;AAC9B,AAAeC,0CAAeC;AAE9B,8CAAA,9CAAKC,+CACC,AAACZ,8DAAOL,yDACR,AAACkB,+DACD,AAACC,+DACD,AAACC,kEACD,AAACC,0EACD,AAAgBC,4EAChB,0DAAA,2CAAA,6DAAA,lKAACC;AAEP","names":["nextjournal.clojure-mode/fold-node-props","coll-span","tree","nextjournal.clojure-mode.node/start","nextjournal.clojure-mode.node/end","nextjournal.clojure-mode/style-tags","cljs.core/clj->js","js/module$node_modules$$codemirror$highlight$dist$index_cjs.tags","nextjournal.clojure-mode/parser","js/module$node_modules$lezer_clojure$dist$index_cjs.parser","var_args","G__41539","nextjournal.clojure-mode/syntax","js/Error","nextjournal.clojure_mode.syntax","parser","js/module$node_modules$$codemirror$language$dist$index_cjs.LezerLanguage","nextjournal.clojure-mode.extensions.formatting/props","js/module$node_modules$$codemirror$language$dist$index_cjs.foldNodeProp","js/module$node_modules$$codemirror$highlight$dist$index_cjs.styleTags","nextjournal.clojure-mode/complete-keymap","nextjournal.clojure-mode.keymap/complete","nextjournal.clojure-mode/builtin-keymap","nextjournal.clojure-mode.keymap/builtin","nextjournal.clojure-mode/paredit-keymap","nextjournal.clojure-mode.keymap/paredit","nextjournal.clojure-mode/default-extensions","nextjournal.clojure-mode.extensions.close-brackets/extension","nextjournal.clojure-mode.extensions.match-brackets/extension","nextjournal.clojure-mode.extensions.selection-history/extension","nextjournal.clojure-mode.extensions.formatting/ext-format-changed-lines","js/module$node_modules$$codemirror$view$dist$index_cjs.EditorView","nextjournal.clojure-mode.extensions.eval-region/extension"],"sourcesContent":["(ns nextjournal.clojure-mode\n  (:require [\"@codemirror/highlight\" :as highlight :refer [tags]]\n            [\"@codemirror/state\" :refer [EditorState]]\n            [\"@codemirror/language\" :as language]\n            [\"@codemirror/view\" :as view :refer [EditorView keymap]]\n            [\"lezer\" :as lezer]\n            [\"lezer-clojure\" :as lezer-clj]\n            [\"lezer-tree\" :as lz-tree]\n            [applied-science.js-interop :as j]\n            [clojure.string :as str]\n            [nextjournal.clojure-mode.extensions.close-brackets :as close-brackets]\n            [nextjournal.clojure-mode.extensions.match-brackets :as match-brackets]\n            [nextjournal.clojure-mode.extensions.formatting :as format]\n            [nextjournal.clojure-mode.extensions.selection-history :as sel-history]\n            [nextjournal.clojure-mode.extensions.eval-region :as eval-region]\n            [nextjournal.clojure-mode.keymap :as keymap]\n            [nextjournal.clojure-mode.node :as n]\n            [nextjournal.clojure-mode.selections :as sel]\n            [nextjournal.clojure-mode.test-utils :as test-utils]\n            [nextjournal.clojure-mode.util :as u]))\n\n(def fold-node-props\n  (let [coll-span (fn [^js tree] #js{:from (inc (n/start tree))\n                                     :to (dec (n/end tree))})]\n    (j/lit\n     {:Vector coll-span\n      :Map coll-span\n      :List coll-span})))\n\n\n(def style-tags\n  (clj->js {:DefLike (.-keyword tags)\n            \"Operator/Symbol\" (.-keyword tags)\n            \"VarName/Symbol\" (.definition tags (.-variableName tags))\n            :Boolean (.-atom tags)\n            \"DocString/...\" (.-emphasis tags)\n            :Discard! (.-comment tags)\n            :Number (.-number tags)\n            :StringContent (.-string tags)\n            ;; need to pass something, that returns \" when being parsed as JSON\n            ;; also #js doesn't treat this correctly, hence clj->js above\n            \"\\\"\\\\\\\"\\\"\" (.-string tags)\n            :Keyword (.-atom tags)\n            :Nil (.-null tags)\n            :LineComment (.-lineComment tags)\n            :RegExp (.-regexp tags)}))\n\n(def parser lezer-clj/parser)\n\n(comment\n  ;; to build a parser \\\"\"live\" from a .grammar file,\n  ;; rather than using a precompiled parser:\n  (def parser\n    (lg/buildParser\n     (shadow.resource/inline \"./clojure/clojure.grammar\")\n     #js{:externalProp n/node-prop})))\n\n(defn syntax\n  ([]\n   (syntax parser))\n  ([^js parser]\n   (.define language/LezerLanguage\n            #js {:parser (.configure parser #js {:props #js [format/props\n                                                             (.add language/foldNodeProp fold-node-props)\n                                                             (highlight/styleTags style-tags)]})}\n            (j/lit\n             {:languageData\n              {:commentTokens {:line \";;\"}}}))))\n\n(def ^js/Array complete-keymap keymap/complete)\n(def ^js/Array builtin-keymap keymap/builtin)\n(def ^js/Array paredit-keymap keymap/paredit)\n\n(def default-extensions\n  #js[(syntax lezer-clj/parser)\n      (close-brackets/extension)\n      (match-brackets/extension)\n      (sel-history/extension)\n      (format/ext-format-changed-lines)\n      (.-lineWrapping EditorView)\n      (eval-region/extension {:modifier \"Alt\"})])\n\n(comment\n\n  (let [state (test-utils/make-state #js[(syntax lezer-clj/parser)] \"[] a\")]\n    (-> (n/tree state)\n        (.resolve 2 1) ;; Symbol \"a\"\n        .-prevSibling\n        js/console.log))\n\n  (let [state (test-utils/make-state #js[(syntax lezer-clj/parser)] \"\\\"\\\" :a\")]\n    (-> state\n        n/tree\n        (n/cursor 0 1)\n        ))\n  (let [state (test-utils/make-state #js[(syntax lezer-clj/parser)] \"a\\n\\nb\")]\n    (-> state\n        (n/tree 1 1)\n        (->> (n/string state))\n        str\n        ))\n  (let [state (test-utils/make-state #js[(syntax lezer-clj/parser)] \"([]| s)\")]\n    (-> state\n        n/tree\n        (n/terminal-cursor 3 1)\n        ))\n\n  (let [state (test-utils/make-state #js[(syntax lezer-clj/parser)] \"(|\")]\n    (-> state\n        (close-brackets/handle-close \")\")\n        (->> (n/string state)))))\n"]}