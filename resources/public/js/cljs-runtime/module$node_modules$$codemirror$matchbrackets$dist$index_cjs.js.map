{
"version":3,
"file":"module$node_modules$$codemirror$matchbrackets$dist$index_cjs.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/@codemirror/matchbrackets/dist/index.cjs"],
"sourcesContent":["shadow$provide[\"module$node_modules$$codemirror$matchbrackets$dist$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar state = require('@codemirror/state');\nvar language = require('@codemirror/language');\nvar view = require('@codemirror/view');\nvar lezerTree = require('lezer-tree');\n\nconst baseTheme = view.EditorView.baseTheme({\n    \".cm-matchingBracket\": { color: \"#0b0\" },\n    \".cm-nonmatchingBracket\": { color: \"#a22\" }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = state.Facet.define({\n    combine(configs) {\n        return state.combineConfig(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist\n        });\n    }\n});\nconst matchingMark = view.Decoration.mark({ class: \"cm-matchingBracket\" }), nonmatchingMark = view.Decoration.mark({ class: \"cm-nonmatchingBracket\" });\nconst bracketMatchingState = state.StateField.define({\n    create() { return view.Decoration.none; },\n    update(deco, tr) {\n        if (!tr.docChanged && !tr.selection)\n            return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges) {\n            if (!range.empty)\n                continue;\n            let match = matchBrackets(tr.state, range.head, -1, config)\n                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))\n                || (config.afterCursor &&\n                    (matchBrackets(tr.state, range.head, 1, config) ||\n                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));\n            if (!match)\n                continue;\n            let mark = match.matched ? matchingMark : nonmatchingMark;\n            decorations.push(mark.range(match.start.from, match.start.to));\n            if (match.end)\n                decorations.push(mark.range(match.end.from, match.end.to));\n        }\n        return view.Decoration.set(decorations, true);\n    },\n    provide: f => view.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/// Create an extension that enables bracket matching. Whenever the\n/// cursor is next to a bracket, that bracket and the one it matches\n/// are highlighted. Or, when no matching bracket is found, another\n/// highlighting style is used to indicate this.\nfunction bracketMatching(config = {}) {\n    return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? lezerTree.NodeProp.openedBy : lezerTree.NodeProp.closedBy);\n    if (byProp)\n        return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n            return [brackets[index + dir]];\n    }\n    return null;\n}\n/// Find the matching bracket for the token at `pos`, scanning\n/// direction `dir`. Only the `brackets` and `maxScanDistance`\n/// properties are used from `config`, if given. Returns null if no\n/// bracket was found at `pos`, or a match result otherwise.\nfunction matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = language.syntaxTree(state), sub = tree.resolve(pos, dir), matches;\n    if (matches = matchingNodes(sub.type, dir, brackets))\n        return matchMarkedBrackets(state, pos, dir, sub, matches, brackets);\n    else\n        return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n    let parent = token.parent, firstToken = { from: token.from, to: token.to };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))\n        do {\n            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n                if (depth == 0 && matching.indexOf(cursor.type.name) > -1) {\n                    return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };\n                }\n                else if (matchingNodes(cursor.type, dir, brackets)) {\n                    depth++;\n                }\n                else if (matchingNodes(cursor.type, -dir, brackets)) {\n                    depth--;\n                    if (depth == 0)\n                        return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: false };\n                }\n            }\n        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return { start: firstToken, matched: false };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\n        return null;\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n        let text = iter.value;\n        if (dir < 0)\n            distance += text.length;\n        let basePos = pos + distance * dir;\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType)\n                continue;\n            if ((found % 2 == 0) == (dir > 0)) {\n                depth++;\n            }\n            else if (depth == 1) { // Closing\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\n            }\n            else {\n                depth--;\n            }\n        }\n        if (dir > 0)\n            distance += text.length;\n    }\n    return iter.done ? { start: startToken, matched: false } : null;\n}\n\nexports.bracketMatching = bracketMatching;\nexports.matchBrackets = matchBrackets;\n\n};"],
"names":["shadow$provide","global","require","module","exports","matchingNodes","node","dir","brackets","byProp","prop","lezerTree","NodeProp","openedBy","closedBy","name","length","index","indexOf","matchBrackets","state","pos","config","maxScanDistance","DefaultScanDist","DefaultBrackets","tree","language","syntaxTree","sub","resolve","matches","type","parent","firstToken","from","to","depth","cursor","childBefore","childAfter","start","end","matched","prevSibling","nextSibling","startCh","sliceDoc","bracket","startToken","iter","doc","iterRange","distance","next","done","text","value","basePos","found","tokenType","Object","defineProperty","view","baseTheme","EditorView","color","bracketMatchingConfig","Facet","define","combine","configs","combineConfig","afterCursor","matchingMark","Decoration","mark","class","nonmatchingMark","bracketMatchingUnique","StateField","bracketMatchingState","create","none","update","deco","tr","docChanged","selection","decorations","facet","range","ranges","empty","match","head","push","set","provide","f","bracketMatching","of"]
}
