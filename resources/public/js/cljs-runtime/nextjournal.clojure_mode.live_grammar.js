goog.provide('nextjournal.clojure_mode.live_grammar');
var module$node_modules$lezer_generator$dist$index_cjs=shadow.js.require("module$node_modules$lezer_generator$dist$index_cjs", {});
nextjournal.clojure_mode.live_grammar.parser = module$node_modules$lezer_generator$dist$index_cjs.buildParser("@external prop prefixColl from \"./props\"\n@external prop coll from \"./props\"\n@external prop prefixEdge from \"./props\"\n@external prop sameEdge from \"./props\"\n@external prop prefixContainer from \"./props\"\n\n@top Program { expression* }\n\n@skip { whitespace | LineComment | Discard }\nexpression { Constructor | Boolean | Nil | Deref | Quote | SyntaxQuote | Unquote | UnquoteSplice | Symbol | Number | Keyword | List | Vector | Map | String | Character | Set | NamespacedMap | RegExp | Var | ReaderConditional | DataLiteral | SymbolicValue | AnonymousFunction | Meta<expression> }\nDiscard { \"#_\" expression }\n@precedence { docString @left, operator @left, meta @right, prefixLiteral @right }\n\nlistContents {\n   defList { defLikeWithMeta varNameWithMeta (DocString expression+ | expression+)? } |\n   anyList { operatorWithMeta? expression* }\n }\n\nDocString { !docString String }\nList[coll] { \"(\" listContents \")\" }\nVector[coll] { \"[\" expression* \"]\" }\nMap[coll] { \"{\" expression* \"}\" }\nVarName { Symbol }\n\ncoll[@isGroup=Coll] {\n  List | Vector | Map\n}\nprefixColl[@isGroup=PrefixColl] {\n  Set |\n  AnonymousFunction |\n  NamespacedMap |\n  Constructor |\n  ReaderConditional |\n  ReaderMetadata |\n  Metadata |\n  Deref |\n  Quote |\n  SyntaxQuote |\n  Unquote |\n  UnquoteSplice\n}\n\nprefixEdge[@isGroup=PrefixEdge] {\n KeywordPrefix |\n ConstructorPrefix |\n \"#\" |\n \"##\" |\n \"#'\" |\n \"#?\" |\n \"#^\" |\n \"#_\" |\n \"'\" |\n \"`\" |\n \"~\" |\n \"~@\" |\n \"^\" |\n \"@\"\n}\n\n@skip {} {\n  dataLiteral { \"#\" ident }\n  DataLiteral { dataLiteral }\n  SymbolicValue { \"##\" ident }\n  Set[prefixColl] { \"#\" Map }\n  AnonymousFunction[prefixColl] { \"#\" List }\n\n  KeywordPrefix[prefixEdge] { \"#\" keyword }\n  NamespacedMap[prefixColl] { KeywordPrefix Map }\n\n  ConstructorPrefix[prefixEdge] { !prefixLiteral  dataLiteral }\n  Constructor[prefixColl] { ConstructorPrefix (Vector | Map) }\n\n  RegExp[prefixColl] { \"#\" String }\n  Var[prefixColl] { \"#'\" Symbol }\n  ReaderConditional[prefixColl] { \"#?\" (List | Deref) }\n  ReaderMetadata[prefixColl] { \"#^\" expression }\n  Metadata[prefixColl] { \"^\" expression }\n  String { '\"' StringContent? '\"' }\n}\n\nMeta[prefixContainer]<t> { (Metadata | ReaderMetadata) !meta t }\n\nDeref[prefixColl] { \"@\" expression }\nQuote[prefixColl] { \"'\" expression }\nSyntaxQuote[prefixColl] { \"`\" expression }\nUnquote[prefixColl] { \"~\" expression }\nUnquoteSplice[prefixColl] { \"~@\" expression }\noperatorWithMeta { Operator | Meta<operatorWithMeta> }\ndefLikeWithMeta { DefLike | Meta<defLikeWithMeta> }\nvarNameWithMeta { VarName | Meta<varNameWithMeta> }\n\nOperator { !operator Symbol }\n\n@tokens {\n\n\n  \"[\"\n  \"{\"\n  \"(\"\n\n  \"#\"[prefixEdge]\n  \"##\"[prefixEdge]\n  \"#'\"[prefixEdge]\n  \"#?\"[prefixEdge]\n  \"#^\"[prefixEdge]\n  \"#_\"[prefixEdge]\n\n  '\"'[sameEdge, closedBy='\"', openedBy='\"']\n  \"'\"[prefixEdge]\n  \"`\"[prefixEdge]\n  \"~\"[prefixEdge]\n  \"~@\"[prefixEdge]\n  \"^\"[prefixEdge]\n  \"@\"[prefixEdge]\n\n\n  \"]\"\n  \"}\"\n  \")\"\n\n  whitespace { (std.whitespace | \",\")+ }\n\n  LineComment { \";\" ![\\n]* }\n\n  identStart { std.asciiLetter | $[<>&%._=?!*+\\-$\\u{a1}-\\u{10ff}/] }\n  identChar { identStart | std.digit | \":\" | \"'\" | \"#\" | \"/\"}\n  ident { identStart identChar* }\n  Symbol { ident }\n\n  keyword { \":\" \":\"? ident? } // the invalid token :: can also be considered as a keyword\n  Keyword { keyword }\n\n  Number {\n    (\"+\" | \"-\")? (std.digit+ (\".\" std.digit* \"M\"?)? | \".\" std.digit+) ((\"e\" | \"E\") (\"+\" | \"-\")? std.digit+ \"M\"?)? |\n    (\"+\" | \"-\")? std.digit+ (\"M\" | \"N\") |\n    (\"+\" | \"-\")? std.digit+ \"/\" std.digit+ |\n    (\"+\" | \"-\")? \"0x\" (std.digit | $[a-fA-F])+ |\n    \"0b\" $[01]+ |\n    \"0o\" $[0-7]+\n  }\n  @precedence { Number, Symbol }\n\n  StringContent {\n    (![\"] | \"\\\\\" _)+\n  }\n\n  Character { \"\\\\\" (std.asciiLetter | std.digit | \"@\")+ }\n\n}\n\nBoolean { @specialize<Symbol, \"true\" | \"false\"> }\nNil { @specialize<Symbol, \"nil\"> }\nDefLike[@dynamicPrecedence=1] { @extend<Symbol, \"def\" | \"defn\" | \"defn-\" | \"defmacro\" | \"definline\" | \"defonce\" | \"deftest\" | \"defcard\"> }\n\n@detectDelim\n",({"externalProp": nextjournal.clojure_mode.node.node_prop}));

//# sourceMappingURL=nextjournal.clojure_mode.live_grammar.js.map
