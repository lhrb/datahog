shadow$provide.module$node_modules$lezer_tree$dist$tree_cjs=function(global,require,module,exports){function withHash(tree,hash){hash&&(tree.contextHash=hash);return tree}function getChildren(node,type,before,after){node=node.cursor;let result=[];if(!node.firstChild())return result;if(null!=before)for(;!node.type.is(before);)if(!node.nextSibling())return result;for(;;){if(null!=after&&node.type.is(after))return result;node.type.is(type)&&result.push(node.node);if(!node.nextSibling())return null==
after?result:[]}}function hasChild(tree){return tree.children.some(ch=>!ch.type.isAnonymous||ch instanceof TreeBuffer||hasChild(ch))}function buildTree(data){function takeNode(parentStart,minPos,children,positions,inRepeat){let {id,start:start$jscomp$0,end,size}=cursor;var startPos$jscomp$0=start$jscomp$0-parentStart;if(0>size)-1==size?(children.push(reused[id]),positions.push(startPos$jscomp$0)):contextHash=id,cursor.next();else{var type=types[id],JSCompiler_temp;if(JSCompiler_temp=end-start$jscomp$0<=
maxBufferLength){var buffer=cursor.pos-minPos;minPos=cursor.fork();let start=JSCompiler_temp=0,skip=0,minStart=minPos.end-maxBufferLength,result={size:0,start:0,skip:0};a:for(let minPos$jscomp$0=minPos.pos-buffer;minPos.pos>minPos$jscomp$0;){if(minPos.id==inRepeat){result.size=JSCompiler_temp;result.start=start;result.skip=skip;skip+=4;JSCompiler_temp+=4;minPos.next();continue}let nodeSize=minPos.size,startPos=minPos.pos-nodeSize;if(0>nodeSize||startPos<minPos$jscomp$0||minPos.start<minStart)break;
let localSkipped=minPos.id>=minRepeatType?4:0,nodeStart=minPos.start;for(minPos.next();minPos.pos>startPos;){if(0>minPos.size)break a;minPos.id>=minRepeatType&&(localSkipped+=4);minPos.next()}start=nodeStart;JSCompiler_temp+=nodeSize;skip+=localSkipped}if(0>inRepeat||JSCompiler_temp==buffer)result.size=JSCompiler_temp,result.start=start,result.skip=skip;JSCompiler_temp=buffer=4<result.size?result:void 0}if(JSCompiler_temp){startPos$jscomp$0=new Uint16Array(buffer.size-buffer.skip);type=cursor.pos-
buffer.size;for(minPos=startPos$jscomp$0.length;cursor.pos>type;)minPos=copyToBuffer(buffer.start,startPos$jscomp$0,minPos,inRepeat);type=new TreeBuffer(startPos$jscomp$0,end-buffer.start,nodeSet,0>inRepeat?NodeType.none:types[inRepeat]);startPos$jscomp$0=buffer.start-parentStart}else{parentStart=cursor.pos-size;cursor.next();inRepeat=[];buffer=[];for(minPos=id>=minRepeatType?id:-1;cursor.pos>parentStart;)cursor.id==minPos?cursor.next():takeNode(start$jscomp$0,parentStart,inRepeat,buffer,minPos);
inRepeat.reverse();buffer.reverse();type=-1<minPos&&8<inRepeat.length?balanceRange(type,type,inRepeat,buffer,0,inRepeat.length,0,maxBufferLength,end-start$jscomp$0,contextHash):withHash(new Tree(type,inRepeat,buffer,end-start$jscomp$0),contextHash)}children.push(type);positions.push(startPos$jscomp$0)}}function copyToBuffer(bufferStart,buffer,index,inRepeat){let {id,start,end,size}=cursor;cursor.next();if(id==inRepeat)return index;let startIndex=index;if(4<size){let endPos=cursor.pos-(size-4);for(;cursor.pos>
endPos;)index=copyToBuffer(bufferStart,buffer,index,inRepeat)}id<minRepeatType&&(buffer[--index]=startIndex,buffer[--index]=end-bufferStart,buffer[--index]=start-bufferStart,buffer[--index]=id);return index}var _a;let {buffer:buffer$jscomp$0,nodeSet,topID=0,maxBufferLength=1024,reused=[],minRepeatType=nodeSet.types.length}=data,cursor=Array.isArray(buffer$jscomp$0)?new FlatBufferCursor(buffer$jscomp$0,buffer$jscomp$0.length):buffer$jscomp$0,types=nodeSet.types,contextHash=0,children$jscomp$0=[],positions$jscomp$0=
[];for(;0<cursor.pos;)takeNode(data.start||0,0,children$jscomp$0,positions$jscomp$0,-1);data=null!==(_a=data.length)&&void 0!==_a?_a:children$jscomp$0.length?positions$jscomp$0[0]+children$jscomp$0[0].length:0;return new Tree(types[topID],children$jscomp$0.reverse(),positions$jscomp$0.reverse(),data)}function balanceRange(outerType,innerType,children,positions,from,to,start,maxBufferLength,length,contextHash){let localChildren=[],localPositions=[];if(length<=maxBufferLength)for(innerType=from;innerType<
to;innerType++)localChildren.push(children[innerType]),localPositions.push(positions[innerType]-start);else{let maxChild=Math.max(maxBufferLength,Math.ceil(1.5*length/8));for(;from<to;){var groupFrom=from;let groupStart=positions[from];for(from++;from<to&&!(positions[from]+children[from].length-groupStart>maxChild);from++);if(from==groupFrom+1){groupFrom=children[groupFrom];if(groupFrom instanceof Tree&&groupFrom.type==innerType&&groupFrom.length>maxChild<<1){for(var j=0;j<groupFrom.children.length;j++)localChildren.push(groupFrom.children[j]),
localPositions.push(groupFrom.positions[j]+groupStart-start);continue}localChildren.push(groupFrom)}else if(from==groupFrom+1)localChildren.push(children[groupFrom]);else{groupFrom=balanceRange(innerType,innerType,children,positions,groupFrom,from,groupStart,maxBufferLength,positions[from-1]+children[from-1].length-groupStart,contextHash);if(j=innerType!=NodeType.none){a:{for(let elt of groupFrom.children)if(elt.type==innerType){j=!0;break a}j=!1}j=!j}j&&(groupFrom=withHash(new Tree(NodeType.none,
groupFrom.children,groupFrom.positions,groupFrom.length),contextHash));localChildren.push(groupFrom)}localPositions.push(groupStart-start)}}return withHash(new Tree(outerType,localChildren,localPositions,length),contextHash)}Object.defineProperty(exports,"__esModule",{value:!0});let nextPropID=0;const CachedNode=new WeakMap;class NodeProp{constructor({deserialize}={}){this.id=nextPropID++;this.deserialize=deserialize||(()=>{throw Error("This node type doesn't define a deserialize function");})}static string(){return new NodeProp({deserialize:str=>
str})}static number(){return new NodeProp({deserialize:Number})}static flag(){return new NodeProp({deserialize:()=>!0})}set(propObj,value){propObj[this.id]=value;return propObj}add(match){"function"!=typeof match&&(match=NodeType.match(match));return type=>{type=match(type);return void 0===type?null:[this,type]}}}NodeProp.closedBy=new NodeProp({deserialize:str=>str.split(" ")});NodeProp.openedBy=new NodeProp({deserialize:str=>str.split(" ")});NodeProp.group=new NodeProp({deserialize:str=>str.split(" ")});
const noProps=Object.create(null);class NodeType{constructor(name,props,id,flags=0){this.name=name;this.props=props;this.id=id;this.flags=flags}static define(spec){let props=spec.props&&spec.props.length?Object.create(null):noProps,type=new NodeType(spec.name||"",props,spec.id,(spec.top?1:0)|(spec.skipped?2:0)|(spec.error?4:0)|(null==spec.name?8:0));if(spec.props)for(let src of spec.props)Array.isArray(src)||(src=src(type)),src&&src[0].set(props,src[1]);return type}prop(prop){return this.props[prop.id]}get isTop(){return 0<
(this.flags&1)}get isSkipped(){return 0<(this.flags&2)}get isError(){return 0<(this.flags&4)}get isAnonymous(){return 0<(this.flags&8)}is(name){if("string"==typeof name){if(this.name==name)return!0;let group=this.prop(NodeProp.group);return group?-1<group.indexOf(name):!1}return this.id==name}static match(map){let direct=Object.create(null);for(let prop in map)for(let name of prop.split(" "))direct[name]=map[prop];return node=>{for(let groups=node.prop(NodeProp.group),i=-1;i<(groups?groups.length:
0);i++){let found=direct[0>i?node.name:groups[i]];if(found)return found}}}}NodeType.none=new NodeType("",Object.create(null),0,8);class NodeSet{constructor(types){this.types=types;for(let i=0;i<types.length;i++)if(types[i].id!=i)throw new RangeError("Node type ids should correspond to array positions when creating a node set");}extend(...props){let newTypes=[];for(let type of this.types){let newProps=null;for(let source of props){let add=source(type);add&&(newProps||(newProps=Object.assign({},type.props)),
add[0].set(newProps,add[1]))}newTypes.push(newProps?new NodeType(type.name,newProps,type.id,type.flags):type)}return new NodeSet(newTypes)}}class Tree{constructor(type,children,positions,length){this.type=type;this.children=children;this.positions=positions;this.length=length}toString(){let children=this.children.map(c=>c.toString()).join();return this.type.name?(/\W/.test(this.type.name)&&!this.type.isError?JSON.stringify(this.type.name):this.type.name)+(children.length?"("+children+")":""):children}cursor(pos,
side=0){var scope=null!=pos&&CachedNode.get(this)||this.topNode;scope=new TreeCursor(scope);null!=pos&&(scope.moveTo(pos,side),CachedNode.set(this,scope._tree));return scope}fullCursor(){return new TreeCursor(this.topNode,!0)}get topNode(){return new TreeNode(this,0,0,null)}resolve(pos,side=0){return this.cursor(pos,side).node}iterate(spec){let {enter,leave,from=0,to=this.length}=spec;for(spec=this.cursor();;){let mustLeave=!1;if(spec.from<=to&&spec.to>=from&&(spec.type.isAnonymous||!1!==enter(spec.type,
spec.from,spec.to))){if(spec.firstChild())continue;spec.type.isAnonymous||(mustLeave=!0)}for(;;){mustLeave&&leave&&leave(spec.type,spec.from,spec.to);if(spec.nextSibling())break;if(!spec.parent())return;mustLeave=!0}}}balance(maxBufferLength=1024){return 8>=this.children.length?this:balanceRange(this.type,NodeType.none,this.children,this.positions,0,this.children.length,0,maxBufferLength,this.length,0)}static build(data){return buildTree(data)}}Tree.empty=new Tree(NodeType.none,[],[],0);class TreeBuffer{constructor(buffer,
length,set,type=NodeType.none){this.buffer=buffer;this.length=length;this.set=set;this.type=type}toString(){let result=[];for(let index=0;index<this.buffer.length;)result.push(this.childString(index)),index=this.buffer[index+3];return result.join(",")}childString(index){let endIndex=this.buffer[index+3];var type=this.set.types[this.buffer[index]];let result=type.name;/\W/.test(result)&&!type.isError&&(result=JSON.stringify(result));index+=4;if(endIndex==index)return result;for(type=[];index<endIndex;)type.push(this.childString(index)),
index=this.buffer[index+3];return result+"("+type.join(",")+")"}findChild(startIndex,endIndex,dir,after){let {buffer}=this,pick=-1;for(;startIndex!=endIndex;startIndex=buffer[startIndex+3])if(-1E8!=after){let start=buffer[startIndex+1],end=buffer[startIndex+2];if(0<dir){if(end>after&&(pick=startIndex),end>after)break}else if(start<after&&(pick=startIndex),end>=after)break}else if(pick=startIndex,0<dir)break;return pick}}class TreeNode{constructor(node,from,index,_parent){this.node=node;this.from=
from;this.index=index;this._parent=_parent}get type(){return this.node.type}get name(){return this.node.type.name}get to(){return this.from+this.node.length}nextChild(i,dir,after,full=!1){for(let parent=this;;){for(let {children,positions}=parent.node,e=0<dir?children.length:-1;i!=e;i+=dir){let next=children[i],start=positions[i]+parent.from;if(!(-1E8!=after&&(0>dir?start>=after:start+next.length<=after)))if(next instanceof TreeBuffer){let index=next.findChild(0,next.buffer.length,dir,-1E8==after?
-1E8:after-start);if(-1<index)return new BufferNode(new BufferContext(parent,next,i,start),null,index)}else if(full||!next.type.isAnonymous||hasChild(next))return i=new TreeNode(next,start,i,parent),full||!i.type.isAnonymous?i:i.nextChild(0>dir?next.children.length-1:0,dir,after)}if(full||!parent.type.isAnonymous)return null;i=parent.index+dir;parent=parent._parent;if(!parent)return null}}get firstChild(){return this.nextChild(0,1,-1E8)}get lastChild(){return this.nextChild(this.node.children.length-
1,-1,-1E8)}childAfter(pos){return this.nextChild(0,1,pos)}childBefore(pos){return this.nextChild(this.node.children.length-1,-1,pos)}nextSignificantParent(){let val=this;for(;val.type.isAnonymous&&val._parent;)val=val._parent;return val}get parent(){return this._parent?this._parent.nextSignificantParent():null}get nextSibling(){return this._parent?this._parent.nextChild(this.index+1,1,-1):null}get prevSibling(){return this._parent?this._parent.nextChild(this.index-1,-1,-1):null}get cursor(){return new TreeCursor(this)}resolve(pos,
side=0){return this.cursor.moveTo(pos,side).node}getChild(type,before=null,after=null){type=getChildren(this,type,before,after);return type.length?type[0]:null}getChildren(type,before=null,after=null){return getChildren(this,type,before,after)}toString(){return this.node.toString()}}class BufferContext{constructor(parent,buffer,index,start){this.parent=parent;this.buffer=buffer;this.index=index;this.start=start}}class BufferNode{constructor(context,_parent,index){this.context=context;this._parent=
_parent;this.index=index;this.type=context.buffer.set.types[context.buffer.buffer[index]]}get name(){return this.type.name}get from(){return this.context.start+this.context.buffer.buffer[this.index+1]}get to(){return this.context.start+this.context.buffer.buffer[this.index+2]}child(dir,after){let {buffer}=this.context;dir=buffer.findChild(this.index+4,buffer.buffer[this.index+3],dir,-1E8==after?-1E8:after-this.context.start);return 0>dir?null:new BufferNode(this.context,this,dir)}get firstChild(){return this.child(1,
-1E8)}get lastChild(){return this.child(-1,-1E8)}childAfter(pos){return this.child(1,pos)}childBefore(pos){return this.child(-1,pos)}get parent(){return this._parent||this.context.parent.nextSignificantParent()}externalSibling(dir){return this._parent?null:this.context.parent.nextChild(this.context.index+dir,dir,-1)}get nextSibling(){let {buffer}=this.context,after=buffer.buffer[this.index+3];return after<(this._parent?buffer.buffer[this._parent.index+3]:buffer.buffer.length)?new BufferNode(this.context,
this._parent,after):this.externalSibling(1)}get prevSibling(){let {buffer}=this.context,parentStart=this._parent?this._parent.index+4:0;return this.index==parentStart?this.externalSibling(-1):new BufferNode(this.context,this._parent,buffer.findChild(parentStart,this.index,-1,-1E8))}get cursor(){return new TreeCursor(this)}resolve(pos,side=0){return this.cursor.moveTo(pos,side).node}toString(){return this.context.buffer.childString(this.index)}getChild(type,before=null,after=null){type=getChildren(this,
type,before,after);return type.length?type[0]:null}getChildren(type,before=null,after=null){return getChildren(this,type,before,after)}}class TreeCursor{constructor(node,full=!1){this.full=full;this.buffer=null;this.stack=[];this.index=0;this.bufferNode=null;if(node instanceof TreeNode)this.yieldNode(node);else{this._tree=node.context.parent;this.buffer=node.context;for(full=node._parent;full;full=full._parent)this.stack.unshift(full.index);this.bufferNode=node;this.yieldBuf(node.index)}}get name(){return this.type.name}yieldNode(node){if(!node)return!1;
this._tree=node;this.type=node.type;this.from=node.from;this.to=node.to;return!0}yieldBuf(index,type){this.index=index;let {start,buffer}=this.buffer;this.type=type||buffer.set.types[buffer.buffer[index]];this.from=start+buffer.buffer[index+1];this.to=start+buffer.buffer[index+2];return!0}yield(node){if(!node)return!1;if(node instanceof TreeNode)return this.buffer=null,this.yieldNode(node);this.buffer=node.context;return this.yieldBuf(node.index,node.type)}toString(){return this.buffer?this.buffer.buffer.childString(this.index):
this._tree.toString()}enter(dir,after){if(!this.buffer)return this.yield(this._tree.nextChild(0>dir?this._tree.node.children.length-1:0,dir,after,this.full));let {buffer}=this.buffer;dir=buffer.findChild(this.index+4,buffer.buffer[this.index+3],dir,-1E8==after?-1E8:after-this.buffer.start);if(0>dir)return!1;this.stack.push(this.index);return this.yieldBuf(dir)}firstChild(){return this.enter(1,-1E8)}lastChild(){return this.enter(-1,-1E8)}childAfter(pos){return this.enter(1,pos)}childBefore(pos){return this.enter(-1,
pos)}parent(){if(!this.buffer)return this.yieldNode(this.full?this._tree._parent:this._tree.parent);if(this.stack.length)return this.yieldBuf(this.stack.pop());let parent=this.full?this.buffer.parent:this.buffer.parent.nextSignificantParent();this.buffer=null;return this.yieldNode(parent)}sibling(dir){if(!this.buffer)return this._tree._parent?this.yield(this._tree._parent.nextChild(this._tree.index+dir,dir,-1E8,this.full)):!1;let {buffer}=this.buffer,d=this.stack.length-1;if(0>dir){var parentStart=
0>d?0:this.stack[d]+4;if(this.index!=parentStart)return this.yieldBuf(buffer.findChild(parentStart,this.index,-1,-1E8))}else if(parentStart=buffer.buffer[this.index+3],parentStart<(0>d?buffer.buffer.length:buffer.buffer[this.stack[d]+3]))return this.yieldBuf(parentStart);return 0>d?this.yield(this.buffer.parent.nextChild(this.buffer.index+dir,dir,-1E8,this.full)):!1}nextSibling(){return this.sibling(1)}prevSibling(){return this.sibling(-1)}atLastNode(dir){var index,parent;({buffer:parent}=this);if(parent){if(0<
dir){if(this.index<parent.buffer.buffer.length)return!1}else for(index=0;index<this.index;index++)if(parent.buffer.buffer[index+3]<this.index)return!1;({index,parent}=parent)}else({index,_parent:parent}=this._tree);for(;parent;{index,_parent:parent}=parent)for(let i=index+dir,e=0>dir?-1:parent.node.children.length;i!=e;i+=dir)if(index=parent.node.children[i],this.full||!index.type.isAnonymous||index instanceof TreeBuffer||hasChild(index))return!1;return!0}move(dir){if(this.enter(dir,-1E8))return!0;
for(;;){if(this.sibling(dir))return!0;if(this.atLastNode(dir)||!this.parent())return!1}}next(){return this.move(1)}prev(){return this.move(-1)}moveTo(pos,side=0){for(;(this.from==this.to||(1>side?this.from>=pos:this.from>pos)||(-1<side?this.to<=pos:this.to<pos))&&this.parent(););for(;0>side?this.childBefore(pos):this.childAfter(pos);)if(this.from==this.to||(1>side?this.from>=pos:this.from>pos)||(-1<side?this.to<=pos:this.to<pos)){this.parent();break}return this}get node(){if(!this.buffer)return this._tree;
var cache=this.bufferNode;let result=null,depth=0;if(cache&&cache.context==this.buffer)a:for(let index=this.index,d=this.stack.length;0<=d;){for(let c=cache;c;c=c._parent)if(c.index==index){if(index==this.index)return c;result=c;depth=d+1;break a}index=this.stack[--d]}for(cache=depth;cache<this.stack.length;cache++)result=new BufferNode(this.buffer,result,this.stack[cache]);return this.bufferNode=new BufferNode(this.buffer,result,this.index)}get tree(){return this.buffer?null:this._tree.node}}class FlatBufferCursor{constructor(buffer,
index){this.buffer=buffer;this.index=index}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}get pos(){return this.index}next(){this.index-=4}fork(){return new FlatBufferCursor(this.buffer,this.index)}}class TreeFragment{constructor(from,to,tree,offset,open){this.from=from;this.to=to;this.tree=tree;this.offset=offset;this.open=open}get openStart(){return 0<(this.open&1)}get openEnd(){return 0<
(this.open&2)}static applyChanges(fragments,changes,minGap=128){if(!changes.length)return fragments;let result=[],fI=1,nextF=fragments.length?fragments[0]:null,cI=0,pos=0,off=0;for(;;){let nextC=cI<changes.length?changes[cI++]:null,nextPos=nextC?nextC.fromA:1E9;if(nextPos-pos>=minGap)for(;nextF&&nextF.from<nextPos;){let cut=nextF;if(pos>=cut.from||nextPos<=cut.to||off){let fFrom=Math.max(cut.from,pos)-off,fTo=Math.min(cut.to,nextPos)-off;cut=fFrom>=fTo?null:new TreeFragment(fFrom,fTo,cut.tree,cut.offset+
off,(0<cI?1:0)|(nextC?2:0))}cut&&result.push(cut);if(nextF.to>nextPos)break;nextF=fI<fragments.length?fragments[fI++]:null}if(!nextC)break;pos=nextC.toA;off=nextC.toA-nextC.toB}return result}static addTree(tree,fragments=[],partial=!1){partial=[new TreeFragment(0,tree.length,tree,0,partial?2:0)];for(let f of fragments)f.to>tree.length&&partial.push(f);return partial}}class StringInput{constructor(string,length=string.length){this.string=string;this.length=length}get(pos){return 0>pos||pos>=this.length?
-1:this.string.charCodeAt(pos)}lineAfter(pos){if(0>pos)return"";let end=this.string.indexOf("\n",pos);return this.string.slice(pos,0>end?this.length:Math.min(end,this.length))}read(from,to){return this.string.slice(from,Math.min(this.length,to))}clip(at){return new StringInput(this.string,at)}}exports.DefaultBufferLength=1024;exports.NodeProp=NodeProp;exports.NodeSet=NodeSet;exports.NodeType=NodeType;exports.Tree=Tree;exports.TreeBuffer=TreeBuffer;exports.TreeCursor=TreeCursor;exports.TreeFragment=
TreeFragment;exports.stringInput=function(input){return new StringInput(input)}}
//# sourceMappingURL=module$node_modules$lezer_tree$dist$tree_cjs.js.map
