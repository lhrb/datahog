shadow$provide.module$node_modules$lezer$dist$index_cjs=function(global,require,module,exports){function decodeArray(input,Type=Uint16Array){if("string"!=typeof input)return input;let array=null;for(let pos=0,out=0;pos<input.length;){let value=0;for(;;){var next=input.charCodeAt(pos++);let stop=!1;if(126==next){value=65535;break}92<=next&&next--;34<=next&&next--;next-=32;46<=next&&(next-=46,stop=!0);value+=next;if(stop)break;value*=46}array?array[out++]=value:array=new Type(value)}return array}function cutAt(tree,
pos,side){let cursor=tree.cursor(pos);for(;;)if(0>side?!cursor.childBefore(pos):!cursor.childAfter(pos))for(;;){if((0>side?cursor.to<pos:cursor.from>pos)&&!cursor.type.isError)return 0>side?Math.max(0,Math.min(cursor.to-1,pos-5)):Math.min(tree.length,Math.max(cursor.from+1,pos+5));if(0>side?cursor.prevSibling():cursor.nextSibling())break;if(!cursor.parent())return 0>side?0:tree.length}}function pushStackDedup(stack,newStacks){for(let i=0;i<newStacks.length;i++){let other=newStacks[i];if(other.pos==
stack.pos&&other.sameState(stack)){newStacks[i].score<stack.score&&(newStacks[i]=stack);return}}newStacks.push(stack)}function pair(data,off){return data[off]|data[off+1]<<16}function findOffset(data,start,term){for(let i=start,next;65535!=(next=data[i]);i++)if(next==term)return i-start;return-1}function findFinished(stacks){let best=null;for(let stack of stacks)stack.pos==stack.p.input.length&&stack.p.parser.stateFlag(stack.state,2)&&(!best||best.score<stack.score)&&(best=stack);return best}global=
require("module$node_modules$process$browser");"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var lezerTree=require("module$node_modules$lezer_tree$dist$tree_cjs");class Stack{constructor(p,stack,state,reducePos,pos,score,buffer,bufferBase,curContext,parent){this.p=p;this.stack=stack;this.state=state;this.reducePos=reducePos;this.pos=pos;this.score=score;this.buffer=buffer;this.bufferBase=bufferBase;this.curContext=curContext;this.parent=parent}toString(){return`[${this.stack.filter((_,
i)=>0==i%3).concat(this.state)}]@${this.pos}${this.score?"!"+this.score:""}`}static start(p,state,pos=0){let cx=p.parser.context;return new Stack(p,[],state,pos,pos,0,[],0,cx?new StackContext(cx,cx.start):null,null)}get context(){return this.curContext?this.curContext.context:null}pushState(state,start){this.stack.push(this.state,start,this.bufferBase+this.buffer.length);this.state=state}reduce(action){var depth=action>>19;let type=action&65535,{parser}=this.p;var dPrec=parser.dynamicPrecedence(type);
dPrec&&(this.score+=dPrec);if(0==depth)type<parser.minRepeatTerm&&this.storeNode(type,this.reducePos,this.reducePos,4,!0),this.pushState(parser.getGoto(this.state,type,!0),this.reducePos);else{depth=this.stack.length-3*(depth-1)-(action&262144?6:0);dPrec=this.stack[depth-2];var count=this.bufferBase+this.buffer.length-this.stack[depth-1];if(type<parser.minRepeatTerm||action&131072){let pos=parser.stateFlag(this.state,1)?this.pos:this.reducePos;this.storeNode(type,dPrec,pos,count+4,!0)}for(this.state=
action&262144?this.stack[depth]:parser.getGoto(this.stack[depth-3],type,!0);this.stack.length>depth;)this.stack.pop()}this.reduceContext(type)}storeNode(term,start,end,size=4,isReduce=!1){if(0==term){let cur=this,top=this.buffer.length;0==top&&cur.parent&&(top=cur.bufferBase-cur.parent.bufferBase,cur=cur.parent);if(0<top&&0==cur.buffer[top-4]&&-1<cur.buffer[top-1]){if(start==end)return;if(cur.buffer[top-2]>=start){cur.buffer[top-2]=end;return}}}if(isReduce&&this.pos!=end){isReduce=this.buffer.length;
if(0<isReduce&&0!=this.buffer[isReduce-4])for(;0<isReduce&&this.buffer[isReduce-2]>end;)this.buffer[isReduce]=this.buffer[isReduce-4],this.buffer[isReduce+1]=this.buffer[isReduce-3],this.buffer[isReduce+2]=this.buffer[isReduce-2],this.buffer[isReduce+3]=this.buffer[isReduce-1],isReduce-=4,4<size&&(size-=4);this.buffer[isReduce]=term;this.buffer[isReduce+1]=start;this.buffer[isReduce+2]=end;this.buffer[isReduce+3]=size}else this.buffer.push(term,start,end,size)}shift(action,next,nextEnd){if(action&
131072)this.pushState(action&65535,this.pos);else if(0==(action&262144)){let start=this.pos,{parser}=this.p;if(nextEnd>this.pos||next<=parser.maxNode)this.pos=nextEnd,parser.stateFlag(action,1)||(this.reducePos=nextEnd);this.pushState(action,start);next<=parser.maxNode&&this.buffer.push(next,start,nextEnd,4);this.shiftContext(next)}else next<=this.p.parser.maxNode&&this.buffer.push(next,this.pos,nextEnd,4),this.pos=nextEnd}apply(action,next,nextEnd){action&65536?this.reduce(action):this.shift(action,
next,nextEnd)}useNode(value,next){let index=this.p.reused.length-1;if(0>index||this.p.reused[index]!=value)this.p.reused.push(value),index++;let start=this.pos;this.reducePos=this.pos=start+value.length;this.pushState(next,start);this.buffer.push(index,start,this.reducePos,-1);this.curContext&&this.updateContext(this.curContext.tracker.reuse(this.curContext.context,value,this.p.input,this))}split(){let parent=this;for(var off=parent.buffer.length;0<off&&parent.buffer[off-2]>parent.reducePos;)off-=
4;let buffer=parent.buffer.slice(off);for(off=parent.bufferBase+off;parent&&off==parent.bufferBase;)parent=parent.parent;return new Stack(this.p,this.stack.slice(),this.state,this.reducePos,this.pos,this.score,buffer,off,this.curContext,parent)}recoverByDelete(next,nextEnd){let isNode=next<=this.p.parser.maxNode;isNode&&this.storeNode(next,this.pos,nextEnd);this.storeNode(0,this.pos,nextEnd,isNode?8:4);this.pos=this.reducePos=nextEnd;this.score-=200}canShift(term){for(let sim=new SimulatedStack(this);;){let action=
this.p.parser.stateSlot(sim.top,4)||this.p.parser.hasAction(sim.top,term);if(0==(action&65536))return!0;if(0==action)return!1;sim.reduce(action)}}get ruleStart(){for(let state=this.state,base=this.stack.length;;){let force=this.p.parser.stateSlot(state,5);if(!(force&65536))return 0;base-=3*(force>>19);if((force&65535)<this.p.parser.minRepeatTerm)return this.stack[base+1];state=this.stack[base]}}startOf(types,before){var state=this.state;let frame=this.stack.length,{parser}=this.p;for(;;){var force=
parser.stateSlot(state,5);state=force>>19;let term=force&65535;if(-1<types.indexOf(term)&&(force=this.stack[frame-3*(force>>19)+1],null==before||before>force))return force;if(0==frame)return null;0==state?(frame-=3,state=this.stack[frame]):(frame-=3*(state-1),state=parser.getGoto(this.stack[frame-3],term,!0))}}recoverByInsert(next){if(300<=this.stack.length)return[];let nextStates=this.p.parser.nextStates(this.state);if(8<nextStates.length||120<=this.stack.length){var best=[];for(let i=0,s;i<nextStates.length;i+=
2)(s=nextStates[i+1])!=this.state&&this.p.parser.hasAction(s,next)&&best.push(nextStates[i],s);if(120>this.stack.length)for(next=0;8>best.length&&next<nextStates.length;next+=2){let s=nextStates[next+1];best.some((v,i)=>i&1&&v==s)||best.push(nextStates[next],s)}nextStates=best}best=[];for(next=0;next<nextStates.length&&4>best.length;next+=2){let s=nextStates[next+1];if(s==this.state)continue;let stack=this.split();stack.storeNode(0,stack.pos,stack.pos,4,!0);stack.pushState(s,this.pos);stack.shiftContext(nextStates[next]);
stack.score-=200;best.push(stack)}return best}forceReduce(){let reduce=this.p.parser.stateSlot(this.state,5);if(0==(reduce&65536))return!1;this.p.parser.validAction(this.state,reduce)||(this.storeNode(0,this.reducePos,this.reducePos,4,!0),this.score-=100);this.reduce(reduce);return!0}forceAll(){for(;!this.p.parser.stateFlag(this.state,2)&&this.forceReduce(););return this}get deadEnd(){if(3!=this.stack.length)return!1;let {parser}=this.p;return 65535==parser.data[parser.stateSlot(this.state,1)]&&!parser.stateSlot(this.state,
4)}restart(){this.state=this.stack[0];this.stack.length=0}sameState(other){if(this.state!=other.state||this.stack.length!=other.stack.length)return!1;for(let i=0;i<this.stack.length;i+=3)if(this.stack[i]!=other.stack[i])return!1;return!0}get parser(){return this.p.parser}dialectEnabled(dialectID){return this.p.parser.dialect.flags[dialectID]}shiftContext(term){this.curContext&&this.updateContext(this.curContext.tracker.shift(this.curContext.context,term,this.p.input,this))}reduceContext(term){this.curContext&&
this.updateContext(this.curContext.tracker.reduce(this.curContext.context,term,this.p.input,this))}emitContext(){let cx=this.curContext;if(cx.tracker.strict){var last=this.buffer.length-1;(0>last||-2!=this.buffer[last])&&this.buffer.push(cx.hash,this.reducePos,this.reducePos,-2)}}updateContext(context){context!=this.curContext.context&&(context=new StackContext(this.curContext.tracker,context),context.hash!=this.curContext.hash&&this.emitContext(),this.curContext=context)}}class StackContext{constructor(tracker,
context){this.tracker=tracker;this.context=context;this.hash=tracker.hash(context)}}var Recover;(function(Recover){Recover[Recover.Token=200]="Token";Recover[Recover.Reduce=100]="Reduce";Recover[Recover.MaxNext=4]="MaxNext";Recover[Recover.MaxInsertStackDepth=300]="MaxInsertStackDepth";Recover[Recover.DampenInsertStackDepth=120]="DampenInsertStackDepth"})(Recover||(Recover={}));class SimulatedStack{constructor(stack){this.stack=stack;this.top=stack.state;this.rest=stack.stack;this.offset=this.rest.length}reduce(action){let term=
action&65535;action>>=19;0==action?(this.rest==this.stack.stack&&(this.rest=this.rest.slice()),this.rest.push(this.top,0,0),this.offset+=3):this.offset-=3*(action-1);this.top=this.stack.p.parser.getGoto(this.rest[this.offset-3],term,!0)}}class StackBufferCursor{constructor(stack,pos,index){this.stack=stack;this.pos=pos;this.index=index;this.buffer=stack.buffer;0==this.index&&this.maybeNext()}static create(stack){return new StackBufferCursor(stack,stack.bufferBase+stack.buffer.length,stack.buffer.length)}maybeNext(){let next=
this.stack.parent;null!=next&&(this.index=this.stack.bufferBase-next.bufferBase,this.stack=next,this.buffer=next.buffer)}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}next(){this.index-=4;this.pos-=4;0==this.index&&this.maybeNext()}fork(){return new StackBufferCursor(this.stack,this.pos,this.index)}}class Token{constructor(){this.end=this.value=this.start=-1}accept(value,
end){this.value=value;this.end=end}}class TokenGroup{constructor(data,id){this.data=data;this.id=id}token(input,token,stack){var data=this.data,state=0;let groupMask=1<<this.id,dialect=stack.p.parser.dialect;a:for(let pos=token.start;0!=(groupMask&data[state]);){let accEnd=data[state+1];for(var i=state+3;i<accEnd;i+=2)if(0<(data[i+1]&groupMask)){var term=data[i];if(dialect.allows(term)&&(-1==token.value||token.value==term||stack.p.parser.overrides(term,token.value))){token.accept(term,pos);break}}i=
input.get(pos++);for(let low=0,high=data[state+2];low<high;){state=low+high>>1;term=accEnd+state+(state<<1);let to=data[term+1];if(i<data[term])high=state;else if(i>=to)low=state+1;else{state=data[term+2];continue a}}break}}}TokenGroup.prototype.contextual=TokenGroup.prototype.fallback=TokenGroup.prototype.extend=!1;class ExternalTokenizer{constructor(token,options={}){this.token=token;this.contextual=!!options.contextual;this.fallback=!!options.fallback;this.extend=!!options.extend}}const verbose=
"undefined"!=typeof global&&/\bparse\b/.test(global.env.LOG);let stackIDs=null;class FragmentCursor{constructor(fragments){this.fragments=fragments;this.i=0;this.fragment=null;this.safeTo=this.safeFrom=-1;this.trees=[];this.start=[];this.index=[];this.nextFragment()}nextFragment(){let fr=this.fragment=this.i==this.fragments.length?null:this.fragments[this.i++];if(fr){this.safeFrom=fr.openStart?cutAt(fr.tree,fr.from+fr.offset,1)-fr.offset:fr.from;for(this.safeTo=fr.openEnd?cutAt(fr.tree,fr.to+fr.offset,
-1)-fr.offset:fr.to;this.trees.length;)this.trees.pop(),this.start.pop(),this.index.pop();this.trees.push(fr.tree);this.start.push(-fr.offset);this.index.push(0);this.nextStart=this.safeFrom}else this.nextStart=1E9}nodeAt(pos){if(pos<this.nextStart)return null;for(;this.fragment&&this.safeTo<=pos;)this.nextFragment();if(!this.fragment)return null;for(;;){let last=this.trees.length-1;if(0>last)return this.nextFragment(),null;var top=this.trees[last];let index=this.index[last];if(index==top.children.length){this.trees.pop();
this.start.pop();this.index.pop();continue}let next=top.children[index];top=this.start[last]+top.positions[index];if(top>pos)return this.nextStart=top,null;if(top==pos&&top+next.length<=this.safeTo)return top==pos&&top>=this.safeFrom?next:null;next instanceof lezerTree.TreeBuffer?(this.index[last]++,this.nextStart=top+next.length):(this.index[last]++,top+next.length>=pos&&(this.trees.push(next),this.start.push(top),this.index.push(0)))}}}class CachedToken extends Token{constructor(){super(...arguments);
this.extended=-1;this.context=this.mask=0}clear(start){this.start=start;this.value=this.extended=-1}}const dummyToken=new Token;class TokenCache{constructor(parser){this.tokens=[];this.mainToken=dummyToken;this.actions=[];this.tokens=parser.tokenizers.map(_=>new CachedToken)}getActions(stack,input){let actionIndex=0,main=null;var {parser}=stack.p;let {tokenizers}=parser;parser=parser.stateSlot(stack.state,3);let context=stack.curContext?stack.curContext.hash:0;for(let i=0;i<tokenizers.length;i++){if(0==
(1<<i&parser))continue;let tokenizer=tokenizers[i],token=this.tokens[i];if(!main||tokenizer.fallback){if(tokenizer.contextual||token.start!=stack.pos||token.mask!=parser||token.context!=context)this.updateCachedToken(token,tokenizer,stack,input),token.mask=parser,token.context=context;if(0!=token.value){let startIndex=actionIndex;-1<token.extended&&(actionIndex=this.addActions(stack,token.extended,token.end,actionIndex));actionIndex=this.addActions(stack,token.value,token.end,actionIndex);if(!tokenizer.extend&&
(main=token,actionIndex>startIndex))break}}}for(;this.actions.length>actionIndex;)this.actions.pop();main||(main=dummyToken,main.start=stack.pos,stack.pos==input.length?main.accept(stack.p.parser.eofTerm,stack.pos):main.accept(0,stack.pos+1));this.mainToken=main;return this.actions}updateCachedToken(token,tokenizer,stack,input){token.clear(stack.pos);tokenizer.token(input,token,stack);if(-1<token.value){({parser:tokenizer}=stack.p);for(let i=0;i<tokenizer.specialized.length;i++)if(tokenizer.specialized[i]==
token.value){let result=tokenizer.specializers[i](input.read(token.start,token.end),stack);if(0<=result&&stack.p.parser.dialect.allows(result>>1)){0==(result&1)?token.value=result>>1:token.extended=result>>1;break}}}else stack.pos==input.length?token.accept(stack.p.parser.eofTerm,stack.pos):token.accept(0,stack.pos+1)}putAction(action,token,end,index){for(let i=0;i<index;i+=3)if(this.actions[i]==action)return index;this.actions[index++]=action;this.actions[index++]=token;this.actions[index++]=end;
return index}addActions(stack,token,end,index){let {state}=stack;({parser:stack}=stack.p);let {data}=stack;for(let set=0;2>set;set++)for(let i=stack.stateSlot(state,set?2:1);;i+=3){if(65535==data[i])if(1==data[i+1])i=pair(data,i+2);else{0==index&&2==data[i+1]&&(index=this.putAction(pair(data,i+1),token,end,index));break}data[i]==token&&(index=this.putAction(pair(data,i+1),token,end,index))}return index}}var Rec;(function(Rec){Rec[Rec.Distance=5]="Distance";Rec[Rec.MaxRemainingPerStep=3]="MaxRemainingPerStep";
Rec[Rec.MinBufferLengthPrune=200]="MinBufferLengthPrune";Rec[Rec.ForceReduceLimit=10]="ForceReduceLimit"})(Rec||(Rec={}));class Parse{constructor(parser,input,startPos,context){this.parser=parser;this.input=input;this.startPos=startPos;this.context=context;this.recovering=this.pos=0;this.nextStackID=9812;this.nested=null;this.nestEnd=0;this.nestWrap=null;this.reused=[];this.tokens=new TokenCache(parser);this.topTerm=parser.top[1];this.stacks=[Stack.start(this,parser.top[0],this.startPos)];this.fragments=
(parser=null===context||void 0===context?void 0:context.fragments)&&parser.length?new FragmentCursor(parser):null}advance(){if(this.nested){var result=this.nested.advance();this.pos=this.nested.pos;result&&(this.finishNested(this.stacks[0],result),this.nested=null);return null}var stacks=this.stacks;let pos=this.pos;result=this.stacks=[];for(let i=0;i<stacks.length;i++){var stack=stacks[i];let nest;for(;;){if(stack.pos>pos)result.push(stack);else if(nest=this.checkNest(stack)){if(!maybeNest||maybeNest.stack.score<
stack.score)var maybeNest=nest}else if(this.advanceStack(stack,result,stacks))continue;else{if(!stopped){var stopped=[];var stoppedTokens=[]}stopped.push(stack);stack=this.tokens.mainToken;stoppedTokens.push(stack.value,stack.end)}break}}if(maybeNest)return this.startNested(maybeNest),null;if(!result.length){if(stacks=stopped&&findFinished(stopped))return this.stackToTree(stacks);if(this.parser.strict)throw verbose&&stopped&&console.log("Stuck with token "+this.parser.getName(this.tokens.mainToken.value)),
new SyntaxError("No parse at "+pos);this.recovering||(this.recovering=5)}if(this.recovering&&stopped&&(stopped=this.runRecovery(stopped,stoppedTokens,result)))return this.stackToTree(stopped.forceAll());if(this.recovering){stopped=1==this.recovering?1:3*this.recovering;if(result.length>stopped)for(result.sort((a,b)=>b.score-a.score);result.length>stopped;)result.pop();result.some(s=>s.reducePos>pos)&&this.recovering--}else if(1<result.length)a:for(stopped=0;stopped<result.length-1;stopped++)for(stoppedTokens=
result[stopped],stacks=stopped+1;stacks<result.length;stacks++)if(maybeNest=result[stacks],stoppedTokens.sameState(maybeNest)||200<stoppedTokens.buffer.length&&200<maybeNest.buffer.length)if(0<(stoppedTokens.score-maybeNest.score||stoppedTokens.buffer.length-maybeNest.buffer.length))result.splice(stacks--,1);else{result.splice(stopped--,1);continue a}this.pos=result[0].pos;for(stopped=1;stopped<result.length;stopped++)result[stopped].pos<this.pos&&(this.pos=result[stopped].pos);return null}advanceStack(stack,
stacks,split){let start=stack.pos,{input,parser}=this,base=verbose?this.stackID(stack)+" -\x3e ":"";if(this.fragments){var strictCx=stack.curContext&&stack.curContext.tracker.strict,cxHash=strictCx?stack.curContext.hash:0;for(var cached=this.fragments.nodeAt(start);cached;){var match=this.parser.nodeSet.types[cached.type.id]==cached.type?parser.getGoto(stack.state,cached.type.id):-1;if(-1<match&&cached.length&&(!strictCx||(cached.contextHash||0)==cxHash))return stack.useNode(cached,match),verbose&&
console.log(base+this.stackID(stack)+` (via reuse of ${parser.getName(cached.type.id)})`),!0;if(!(cached instanceof lezerTree.Tree)||0==cached.children.length||0<cached.positions[0])break;cached=cached.children[0];if(!(cached instanceof lezerTree.Tree))break}}strictCx=parser.stateSlot(stack.state,4);if(0<strictCx)return stack.reduce(strictCx),verbose&&console.log(base+this.stackID(stack)+` (via always-reduce ${parser.getName(strictCx&65535)})`),!0;strictCx=this.tokens.getActions(stack,input);for(cxHash=
0;cxHash<strictCx.length;){cached=strictCx[cxHash++];match=strictCx[cxHash++];let end=strictCx[cxHash++],last=cxHash==strictCx.length||!split,localStack=last?stack:stack.split();localStack.apply(cached,match,end);verbose&&console.log(base+this.stackID(localStack)+` (via ${0==(cached&65536)?"shift":`reduce of ${parser.getName(cached&65535)}`} for ${parser.getName(match)} @ ${start}${localStack==stack?"":", split"})`);if(last)return!0;localStack.pos>start?stacks.push(localStack):split.push(localStack)}return!1}advanceFully(stack,
newStacks){let pos=stack.pos;for(;;){let nest=this.checkNest(stack);if(nest)return nest;if(!this.advanceStack(stack,null,null))return!1;if(stack.pos>pos)return pushStackDedup(stack,newStacks),!0}}runRecovery(stacks,tokens,newStacks){let finished=null,restarted=!1,maybeNest;for(let i=0;i<stacks.length;i++){let stack=stacks[i],token=tokens[i<<1],tokenEnd=tokens[(i<<1)+1],base=verbose?this.stackID(stack)+" -\x3e ":"";if(stack.deadEnd){if(restarted)continue;restarted=!0;stack.restart();verbose&&console.log(base+
this.stackID(stack)+" (restarted)");var done$jscomp$0=this.advanceFully(stack,newStacks);if(done$jscomp$0){!0!==done$jscomp$0&&(maybeNest=done$jscomp$0);continue}}done$jscomp$0=stack.split();let forceBase=base;for(let j=0;done$jscomp$0.forceReduce()&&10>j;j++){verbose&&console.log(forceBase+this.stackID(done$jscomp$0)+" (via force-reduce)");let done=this.advanceFully(done$jscomp$0,newStacks);if(done){!0!==done&&(maybeNest=done);break}verbose&&(forceBase=this.stackID(done$jscomp$0)+" -\x3e ")}for(let insert of stack.recoverByInsert(token))verbose&&
console.log(base+this.stackID(insert)+" (via recover-insert)"),this.advanceFully(insert,newStacks);if(this.input.length>stack.pos)tokenEnd==stack.pos&&(tokenEnd++,token=0),stack.recoverByDelete(token,tokenEnd),verbose&&console.log(base+this.stackID(stack)+` (via recover-delete ${this.parser.getName(token)})`),pushStackDedup(stack,newStacks);else if(!finished||finished.score<stack.score)finished=stack}if(finished)return finished;if(maybeNest)for(let s of this.stacks)if(s.score>maybeNest.stack.score){maybeNest=
void 0;break}maybeNest&&this.startNested(maybeNest);return null}forceFinish(){let stack=this.stacks[0].split();this.nested&&this.finishNested(stack,this.nested.forceFinish());return this.stackToTree(stack.forceAll())}stackToTree(stack,pos=stack.pos){this.parser.context&&stack.emitContext();return lezerTree.Tree.build({buffer:StackBufferCursor.create(stack),nodeSet:this.parser.nodeSet,topID:this.topTerm,maxBufferLength:this.parser.bufferLength,reused:this.reused,start:this.startPos,length:pos-this.startPos,
minRepeatType:this.parser.minRepeatTerm})}checkNest(stack){let info=this.parser.findNested(stack.state);if(!info)return null;let spec=info.value;"function"==typeof spec&&(spec=spec(this.input,stack));return spec?{stack,info,spec}:null}startNested(nest){let {stack,info,spec}=nest;this.stacks=[stack];this.nestEnd=this.scanForNestEnd(stack,info.end,spec.filterEnd);this.nestWrap="number"==typeof spec.wrapType?this.parser.nodeSet.types[spec.wrapType]:spec.wrapType||null;spec.startParse?this.nested=spec.startParse(this.input.clip(this.nestEnd),
stack.pos,this.context):this.finishNested(stack)}scanForNestEnd(stack,endToken,filter){for(let pos=stack.pos;pos<this.input.length;pos++)if(dummyToken.start=pos,dummyToken.value=-1,endToken.token(this.input,dummyToken,stack),-1<dummyToken.value&&(!filter||filter(this.input.read(pos,dummyToken.end))))return pos;return this.input.length}finishNested(stack,tree){this.nestWrap?tree=new lezerTree.Tree(this.nestWrap,tree?[tree]:[],tree?[0]:[],this.nestEnd-stack.pos):tree||(tree=new lezerTree.Tree(lezerTree.NodeType.none,
[],[],this.nestEnd-stack.pos));let info=this.parser.findNested(stack.state);stack.useNode(tree,this.parser.getGoto(stack.state,info.placeholder,!0));verbose&&console.log(this.stackID(stack)+" (via unnest)")}stackID(stack){let id=(stackIDs||(stackIDs=new WeakMap)).get(stack);id||stackIDs.set(stack,id=String.fromCodePoint(this.nextStackID++));return id+stack}}class Dialect{constructor(source,flags,disabled){this.source=source;this.flags=flags;this.disabled=disabled}allows(term){return!this.disabled||
0==this.disabled[term]}}const id$jscomp$1=x=>x;class ContextTracker{constructor(spec){this.start=spec.start;this.shift=spec.shift||id$jscomp$1;this.reduce=spec.reduce||id$jscomp$1;this.reuse=spec.reuse||id$jscomp$1;this.hash=spec.hash;this.strict=!1!==spec.strict}}class Parser{constructor(spec){function setProp(nodeID,prop,value){nodeProps[nodeID].push([prop,prop.deserialize(String(value))])}this.bufferLength=lezerTree.DefaultBufferLength;this.strict=!1;this.cachedDialect=null;if(13!=spec.version)throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13})`);
let tokenArray=decodeArray(spec.tokenData),nodeNames=spec.nodeNames.split(" ");this.minRepeatTerm=nodeNames.length;this.context=spec.context;for(var i$jscomp$0=0;i$jscomp$0<spec.repeatNodeCount;i$jscomp$0++)nodeNames.push("");let nodeProps=[];for(i$jscomp$0=0;i$jscomp$0<nodeNames.length;i$jscomp$0++)nodeProps.push([]);if(spec.nodeProps)for(var propSpec of spec.nodeProps){i$jscomp$0=propSpec[0];for(let i=1;i<propSpec.length;){var next=propSpec[i++];if(0<=next)setProp(next,i$jscomp$0,propSpec[i++]);
else{let value=propSpec[i+-next];for(next=-next;0<next;next--)setProp(propSpec[i++],i$jscomp$0,value);i++}}}this.specialized=new Uint16Array(spec.specialized?spec.specialized.length:0);this.specializers=[];if(spec.specialized)for(propSpec=0;propSpec<spec.specialized.length;propSpec++)this.specialized[propSpec]=spec.specialized[propSpec].term,this.specializers[propSpec]=spec.specialized[propSpec].get;this.states=decodeArray(spec.states,Uint32Array);this.data=decodeArray(spec.stateData);this.goto=decodeArray(spec.goto);
let topTerms=Object.keys(spec.topRules).map(r=>spec.topRules[r][1]);this.nodeSet=new lezerTree.NodeSet(nodeNames.map((name,i)=>lezerTree.NodeType.define({name:i>=this.minRepeatTerm?void 0:name,id:i,props:nodeProps[i],top:-1<topTerms.indexOf(i),error:0==i,skipped:spec.skippedNodes&&-1<spec.skippedNodes.indexOf(i)})));this.maxTerm=spec.maxTerm;this.tokenizers=spec.tokenizers.map(value=>"number"==typeof value?new TokenGroup(tokenArray,value):value);this.topRules=spec.topRules;this.nested=(spec.nested||
[]).map(([name,value,endToken,placeholder])=>({name,value,end:new TokenGroup(decodeArray(endToken),0),placeholder}));this.dialects=spec.dialects||{};this.dynamicPrecedences=spec.dynamicPrecedences||null;this.tokenPrecTable=spec.tokenPrec;this.termNames=spec.termNames||null;this.maxNode=this.nodeSet.types.length-1;this.dialect=this.parseDialect();this.top=this.topRules[Object.keys(this.topRules)[0]]}parse(input,startPos=0,context={}){"string"==typeof input&&(input=lezerTree.stringInput(input));for(input=
new Parse(this,input,startPos,context);;)if(startPos=input.advance())return startPos}startParse(input,startPos=0,context={}){"string"==typeof input&&(input=lezerTree.stringInput(input));return new Parse(this,input,startPos,context)}getGoto(state,term,loose=!1){let table=this.goto;if(term>=table[0])return-1;for(term=table[term+1];;){var groupTag=table[term++];let last=groupTag&1,target=table[term++];if(last&&loose)return target;for(groupTag=term+(groupTag>>1);term<groupTag;term++)if(table[term]==state)return target;
if(last)return-1}}hasAction(state,terminal){let data=this.data;for(let set=0;2>set;set++)for(let i=this.stateSlot(state,set?2:1),next;;i+=3){if(65535==(next=data[i]))if(1==data[i+1])next=data[i=pair(data,i+2)];else{if(2==data[i+1])return pair(data,i+2);break}if(next==terminal||0==next)return pair(data,i+1)}return 0}stateSlot(state,slot){return this.states[6*state+slot]}stateFlag(state,flag){return 0<(this.stateSlot(state,0)&flag)}findNested(state){state=this.stateSlot(state,0);return state&4?this.nested[state>>
10]:null}validAction(state,action){if(action==this.stateSlot(state,4))return!0;for(state=this.stateSlot(state,1);;state+=3){if(65535==this.data[state])if(1==this.data[state+1])state=pair(this.data,state+2);else return!1;if(action==pair(this.data,state+1))return!0}}nextStates(state){let result=[];for(state=this.stateSlot(state,1);;state+=3){if(65535==this.data[state])if(1==this.data[state+1])state=pair(this.data,state+2);else break;if(0==(this.data[state+2]&1)){let value=this.data[state+1];result.some((v,
i)=>i&1&&v==value)||result.push(this.data[state],value)}}return result}overrides(token,prev){prev=findOffset(this.data,this.tokenPrecTable,prev);return 0>prev||findOffset(this.data,this.tokenPrecTable,token)<prev}configure(config){let copy=Object.assign(Object.create(Parser.prototype),this);config.props&&(copy.nodeSet=this.nodeSet.extend(...config.props));if(config.top){let info=this.topRules[config.top];if(!info)throw new RangeError(`Invalid top rule name ${config.top}`);copy.top=info}config.tokenizers&&
(copy.tokenizers=this.tokenizers.map(t=>{let found=config.tokenizers.find(r=>r.from==t);return found?found.to:t}));config.dialect&&(copy.dialect=this.parseDialect(config.dialect));config.nested&&(copy.nested=this.nested.map(obj=>Object.prototype.hasOwnProperty.call(config.nested,obj.name)?{name:obj.name,value:config.nested[obj.name],end:obj.end,placeholder:obj.placeholder}:obj));null!=config.strict&&(copy.strict=config.strict);null!=config.bufferLength&&(copy.bufferLength=config.bufferLength);return copy}getName(term){return this.termNames?
this.termNames[term]:String(term<=this.maxNode&&this.nodeSet.types[term].name||term)}get eofTerm(){return this.maxNode+1}get hasNested(){return 0<this.nested.length}get topNode(){return this.nodeSet.types[this.top[1]]}dynamicPrecedence(term){let prec=this.dynamicPrecedences;return null==prec?0:prec[term]||0}parseDialect(dialect){if(this.cachedDialect&&this.cachedDialect.source==dialect)return this.cachedDialect;let values=Object.keys(this.dialects),flags=values.map(()=>!1);if(dialect)for(var part of dialect.split(" ")){var id$jscomp$0=
values.indexOf(part);0<=id$jscomp$0&&(flags[id$jscomp$0]=!0)}part=null;for(id$jscomp$0=0;id$jscomp$0<values.length;id$jscomp$0++)if(!flags[id$jscomp$0])for(let j=this.dialects[values[id$jscomp$0]],id;65535!=(id=this.data[j++]);)(part||(part=new Uint8Array(this.maxTerm+1)))[id]=1;return this.cachedDialect=new Dialect(dialect,flags,part)}static deserialize(spec){return new Parser(spec)}}exports.NodeProp=lezerTree.NodeProp;exports.NodeSet=lezerTree.NodeSet;exports.NodeType=lezerTree.NodeType;exports.Tree=
lezerTree.Tree;exports.TreeCursor=lezerTree.TreeCursor;exports.ContextTracker=ContextTracker;exports.ExternalTokenizer=ExternalTokenizer;exports.Parser=Parser;exports.Stack=Stack;exports.Token=Token}
//# sourceMappingURL=module$node_modules$lezer$dist$index_cjs.js.map
