{"version":3,"sources":["nextjournal/clojure_mode/chars.cljs"],"mappings":";;AAGA,6CAAA,7CAAMA,kGAAaC,WAAmBC;AAAtC,AACE,IAAMC,MAAI,AAACC,gBAAMH;IACXI,KAAG,sEAAA,tEAACC,gEAAiBJ;AAD3B,AAEE,QAAA,JAAOK;;AAAP,AACE,GAAM,CAAIA,KAAEJ;AAAK,OAACK,kEAAmB,EAAI,MAAA,LAAGH,aAAQA,GAAG,MAAA,LAAKA;;AAA5D,GACM,CAAIA,OAAG,AAAaJ,sBAAWM;AAAI,OAASN,kBAAW,KAAA,JAAKM;;AADlE,AAEY,eAAO,KAAA,JAAGA;;;;;;;;;AAE5B,kDAAA,lDAAME,4GAAoBC;AAA1B,AAAgC,iBAAA,TAAIA;;AAEpC,2CAAA,3CAAMC,8FAAeC,IAAYC;AAAjC,AACE,IAAcC,OAAK,AAAcF,gBAAIC,IAAI,OAAA,NAAGA;AAA5C,AACE,kBAAA,XAAQC,eAAO,AAACC,kEAAmB,qEAAA,rEAACT,gEAAiBQ;;AAEzD,2CAAA,3CAAME,8FAAeJ,IAAYC;AAAjC,AACE,GAAI,AAACI,yBAASJ;AACZ,OAAcD,gBAAI,OAAA,NAAKC,WAAKA;;AAD9B;;;AAIF,AAAKK,iEACiB,4CAAA,WAAAC,vDAACC,dACD,AAACC;AADD,AAAM,OAAAF,4BAAA;GAAN,mFAAA,IAAA,IAAA,IAAA;AAGtB","names":["nextjournal.clojure-mode.chars/pair-lookup","char-pairs","char","end","cljs.core/count","ch","js/module$node_modules$$codemirror$text$dist$index_cjs.codePointAt","i","js/module$node_modules$$codemirror$text$dist$index_cjs.fromCodePoint","nextjournal.clojure-mode.chars/backspace?","code","nextjournal.clojure-mode.chars/next-char","doc","pos","next","js/module$node_modules$$codemirror$text$dist$index_cjs.codePointSize","nextjournal.clojure-mode.chars/prev-char","cljs.core/pos-int?","nextjournal.clojure-mode.chars/whitespace?","p1__51203#","cljs.core.map","cljs.core/set"],"sourcesContent":["(ns nextjournal.clojure-mode.chars\n  (:require [\"@codemirror/text\" :as text]))\n\n(defn pair-lookup [char-pairs ^string char]\n  (let [end (count char-pairs)\n        ch (text/codePointAt char 0)]\n    (loop [i 0]\n      (cond (>= i end) (text/fromCodePoint (if (< ch 128) ch (inc ch)))\n            (== ch (.charCodeAt char-pairs i)) (.charAt char-pairs (inc i))\n            :else (recur (+ i 2))))))\n\n(defn backspace? [^number code] (== code 8))\n\n(defn next-char [^js doc ^number pos]\n  (let [^string next (.sliceString doc pos (+ pos 2))]\n    (.slice next 0 (text/codePointSize (text/codePointAt next 0)))))\n\n(defn prev-char [^js doc ^number pos]\n  (if (pos-int? pos)\n    (.sliceString doc (dec pos) pos)\n    \"\"))\n\n(def whitespace? (->> [\" \" \\n \\r \",\"]\n                      (map #(.charCodeAt ^string % 0))\n                      (set)))\n\n(comment\n ;; is there a way to iterate from a position, character by character?\n (defn pos-when [doc dir pred]\n   ))\n"]}