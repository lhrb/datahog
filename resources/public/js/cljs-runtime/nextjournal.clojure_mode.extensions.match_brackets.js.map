{"version":3,"sources":["nextjournal/clojure_mode/extensions/match_brackets.cljs"],"mappings":";;;AAWA,AAAKA,yIAED,qBAAA,UAAA,+BAAA,UAAA,jJAEA,AAAYC;AAEhB,AAASC,mEAAc,AAAOC,oEAAW,UAAA;AACzC,AAASC,sEAAiB,AAAOD,oEAAW,UAAA;AAE5C,+DAAA,/DAAME,sIAAWC,KAASC;AAA1B,AACE,OAAQA,WAAK,AAACC,oCAAQF,MAAM,AAACG,kCAAMH;;AAErC,AAAKI,kIAEF,WACU,AAACC,qBAAW,AAAQR,8EACpB,gBAAAS,LAAOgB,hMAgDjB,AAASiD;AAhDC,AAAA,IAAAhE,aAAAD;IAAAC,iBAAA,EAAA,EAAA,GAAA,CAAAA,cAAA,SAAA,EAAA,EAAA,CAAA,AAAAA,iDAAA,WAAA,CAAAC,gCAAA,AAAAD,+BAAA,KAAA,OAAA,QAAA,AAAAE,8CAAAC,mBAAAH,YAAAA;SAAAA,LAAsBgB;YAAtB,iBAAAZ,WAAAJ,pCAAgCiB;IAAhCZ,SAAA;AAAA,AAAA,GAAA,iBAAAC,WAAAF;AAAA,AAAA,SAAA,GAAA,CAAAE,YAAA,aAAA,AAAAC,gDAAAF,OAAAC;;AAAA,QAAAF,SAAAC;;AAAAG;;;iBAAA,iBAAAC,WAAAT,zCAAsCkB;IAAtCR,SAAA;AAAA,AAAA,GAAA,iBAAAC,WAAAF;AAAA,AAAA,SAAA,GAAA,CAAAE,YAAA,aAAA,AAAAJ,gDAAAG,OAAAC;;AAAA,QAAAF,SAAAC;;AAAAF;;;gBAAA,iBAAAI,WAAAZ,xCAAiDmB;IAAjDN,SAAA;AAAA,AAAA,GAAA,iBAAAC,WAAAF;AAAA,AAAA,SAAA,GAAA,CAAAE,YAAA,aAAA,AAAAP,gDAAAM,OAAAC;;AAAA,QAAAF,SAAAC;;AAAAL;;;AAAA,AAAA,AACE,oBAAI,iBAAAY,mBAAIF;AAAJ,AAAA,oBAAAE;AAAAA;;AAAeD;;;AACjB,IAAME,QACW,AAACC,+CACA,eAAAC,JAAOQ;AAAP,AAAA,IAAAP,aAAAD;IAAAC,iBAAA,EAAA,EAAA,GAAA,CAAAA,cAAA,SAAA,EAAA,EAAA,CAAA,AAAAA,iDAAA,WAAA,CAAAvB,gCAAA,AAAAuB,+BAAA,KAAA,OAAA,QAAA,AAAAtB,8CAAAC,mBAAAqB,YAAAA;WAAA,iBAAAC,WAAAD,nCAAwBQ;IAAxBN,SAAA;AAAA,AAAA,GAAA,iBAAAC,WAAAF;AAAA,AAAA,SAAA,GAAA,CAAAE,YAAA,aAAA,AAAApB,gDAAAmB,OAAAC;;AAAA,QAAAF,SAAAC;;AAAAlB;;;YAAA,iBAAAoB,WAAAJ,pCAA6BS;IAA7BJ,SAAA;AAAA,AAAA,GAAA,iBAAAC,WAAAF;AAAA,AAAA,SAAA,GAAA,CAAAE,YAAA,aAAA,AAAAvB,gDAAAsB,OAAAC;;AAAA,QAAAF,SAAAC;;AAAArB;;;AAAA,AAAA,AACE,IAAAY,mBAEC,iBAAAc,qBAAmB,iBAAAE,oBAAKH;AAAL,AAAA,oBAAAG;AACK,wSAAM,4EAAA,5EAACC,iEAAOpB,MAAMe,WAAS,4EAAA,5EAACK,iEAAOpB,MAAMe,1aACtC,8LAAA,9LAACM,+CAAO,AAACC,gDAAQC,gDAAcC,/JAC/BC;;AAHVN;;;AAAnB,AAAA,oBAAAF;AAAA,AAAA,cAAAA,VAAWC;AAAX,AAKE,IAAAQ,qBAAuB,EAGE,EAAK,AAACH,gDAAcL,cACf,AAACU,6CAAE,AAAClD,oCAAQwC,SACT,AAACxC,oCAAQ,AAACmD,iCAAKX,2HAEnBA,jCAAQW,xCAAKC,pCACb,oCAAA,wCAAA,2CAAA,WAAAC,lIAACC;AAAD,AAAU,OAACJ,6CAAE,mCAAAG,nCAACE,qDACD,AAACC,wCAAYhB;IAThC,EAYE,EAAK,AAACM,8CAAYN,cACb,AAACU,6CAAE,AAACjD,kCAAMuC,SACP,AAACvC,kCAAM,AAACkD,iCAAKX,sHAEjBA,jCAAQW,nCAAKM,pCACb,oCAAA,mCAAA,2CAAA,WAAAC,7HAACJ;AAAD,AAAU,OAACJ,6CAAE,mCAAAQ,nCAACH,qDACD,AAACI,wCAAYnB;IAlBhC;AAAvB,AAAA,oBAAAQ;AAAA,oBAAAA,hBAASC;AAAT,AAmBE,OAACW,oDAAKxB,IACA,AAACvC,6DAAU2C,QAAQ9C,oHACnB,AAACG,6DAAUoD,cAAcvD;;AAC/B,OAACkE,6CAAKxB,IAAI,AAACvC,6DAAU2C,QAAQ5C;;;AA3BjC;;;AAFD,AAAA,oBAAA6B;AAAAA;;AAAA,IAAAA,uBAkCC,iBAAAc,qBAA4B,iBAAAE,oBAEC,AAACqB,oDAAQ,AAACpB,iEAAOpB,MAAMe,7GAAM,AAAC0B,mHAAUC;AAFzC,AAAA,GAAAvB;eAGK,AAAA,AAAA,AAAA,AAAIpB,mBAAsBgB,KAAK,QAAA,PAAKA,xCACpC,IAAA4B;IAAAC,eAAA,iFAAA,SAAA,SAAA;AAAA,AAAA,QAAAA,6CAAAA,2CAAAD,YAAAC,uBAAAD;;AAJLxB;;;AAA5B,AAAA,oBAAAF;AAAA,AAAA,uBAAAA,nBAAWsB;AAAX,AAKE,OAACD,6CAAKxB,IAAI,AAACvC,6DAAU,AAACsE,oEAAU9B,KAAK,QAAA,PAAKA,aAAOzC;;AALnD;;;AAlCD,AAAA,oBAAA6B;AAAAA;;AAwCCW;;;oCA3CJ,AAAA,AAAA,AAAIf,jCACJ;AADjB,AA4CE,oIAAA,7HAAM1B,mEAAW,AAACyE,mDAAW1C;;AAC/BN;;;AAGjB,+DAAA,/DAAMkD;AAAN,AAAA,QACM9E,8DACAU,yDACA,AAAA,AAAIT,gFAA8BS","names":["nextjournal.clojure-mode.extensions.match-brackets/base-theme","js/module$node_modules$$codemirror$view$dist$index_cjs.EditorView","nextjournal.clojure-mode.extensions.match-brackets/matching-mark","js/module$node_modules$$codemirror$view$dist$index_cjs.Decoration","nextjournal.clojure-mode.extensions.match-brackets/nonmatching-mark","nextjournal.clojure-mode.extensions.match-brackets/mark-node","node","mark","nextjournal.clojure-mode.node/start","nextjournal.clojure-mode.node/end","nextjournal.clojure-mode.extensions.match-brackets/state","cljs.core/constantly","p__41456","map__41462","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","obj41485","k41486","obj41487","applied-science.js-interop.impl/in?*","js/undefined","obj41500","k41501","obj41502","obj41505","k41506","obj41507","deco","tr","state","docChanged","selection","or__4223__auto__","decos","cljs.core.reduce","p__41512","map__41513","obj41515","k41516","obj41517","obj41518","k41519","obj41520","out","head","empty","temp__5754__auto__","bracket","and__4221__auto__","nextjournal.clojure_mode.node.tree","cljs.core.filter","cljs.core.some_fn","nextjournal.clojure-mode.node/start-edge?","nextjournal.clojure-mode.node/end-edge?","cljs.core/first","temp__5752__auto__","other-bracket","cljs.core._EQ_","nextjournal.clojure-mode.node/up","nextjournal.clojure-mode.node/down-last","p1__41445#","nextjournal.clojure-mode.util/guard","nextjournal.clojure-mode.node/name","nextjournal.clojure-mode.node/closed-by","nextjournal.clojure-mode.node/down","p1__41448#","nextjournal.clojure-mode.node/opened-by","cljs.core.conj","unparsed-bracket","cljs.core/not","nextjournal.clojure-mode.node/closest","nextjournal.clojure-mode.node/string?","G__41522","fexpr__41521","nextjournal.clojure_mode.node.from_to","cljs.core.into_array","js/module$node_modules$$codemirror$state$dist$index_cjs.StateField","nextjournal.clojure-mode.extensions.match-brackets/extension"],"sourcesContent":["(ns nextjournal.clojure-mode.extensions.match-brackets\n  (:require\n   [\"@codemirror/state\" :refer [EditorState\n                                StateField\n                                Extension]]\n   [\"@codemirror/view\" :refer [EditorView\n                               Decoration DecorationSet]]\n   [applied-science.js-interop :as j]\n   [nextjournal.clojure-mode.node :as n]\n   [nextjournal.clojure-mode.util :as u]))\n\n(def base-theme\n  (->>\n    (j/lit {:$matchingBracket {:color \"#0b0\"}\n            :$nonmatchingBracket {:color \"#a22\"}})\n    (.baseTheme EditorView)))\n\n(def ^js matching-mark (.mark Decoration (j/obj :class \"cm-matchingBracket\")))\n(def ^js nonmatching-mark (.mark Decoration (j/obj :class \"cm-nonmatchingBracket\")))\n\n(defn mark-node [node ^js mark]\n  (.range mark (n/start node) (n/end node)))\n\n(def state\n  (->>\n   (j/lit\n    {:create (constantly (.-none Decoration))\n     :update (j/fn [deco ^:js {:as tr :keys [state docChanged selection]}]\n               (if (or docChanged selection)\n                 (let [decos (->> (.. tr -state -selection -ranges)\n                                  (reduce\n                                   (j/fn [out ^:js {:keys [head empty]}]\n                                     (or\n                                      ;; a parsed bracket is found before/after cursor\n                                      (when-let [bracket (and empty\n                                                              (->> [(n/tree state head -1) (n/tree state head 1)]\n                                                                   (filter (some-fn n/start-edge? n/end-edge?))\n                                                                   first))]\n                                        ;; try finding a matching bracket\n                                        (if-let [other-bracket (cond\n\n                                                                 ;; are we at starting position?\n                                                                 (and (n/start-edge? bracket)\n                                                                      (= (n/start bracket)\n                                                                         (n/start (n/up bracket))))\n                                                                 ;; get end-bracket\n                                                                 (-> bracket n/up n/down-last\n                                                                     (u/guard #(= (n/name %)\n                                                                                  (n/closed-by bracket))))\n\n                                                                 ;; are we at ending position?\n                                                                 (and (n/end-edge? bracket)\n                                                                      (= (n/end bracket)\n                                                                         (n/end (n/up bracket))))\n                                                                 ;; get start-bracket\n                                                                 (-> bracket n/up n/down\n                                                                     (u/guard #(= (n/name %)\n                                                                                  (n/opened-by bracket)))))]\n                                          (conj out\n                                                (mark-node bracket matching-mark)\n                                                (mark-node other-bracket matching-mark))\n                                          (conj out (mark-node bracket nonmatching-mark))))\n                                      ;; lezer does not produce tokens for non-matching close-brackets\n                                      ;; (we haven't entered a collection, so brackets are not valid tokens\n                                      ;;  and aren't parsed). So we need to check the string to see if an\n                                      ;; unmatched bracket is sitting in front of the cursor.\n                                      (when-let [unparsed-bracket (and\n                                                                   ;; skip this check if we're inside a string\n                                                                   (not (-> (n/tree state head) (n/closest n/string?)))\n                                                                   (-> (.. tr -state -doc (slice head (inc head)) toString)\n                                                                       (#{\\] \\) \\}})))]\n                                        (conj out (mark-node (n/from-to head (inc head)) nonmatching-mark)))\n                                      out)) []))]\n                   (.set Decoration (into-array decos) true))\n                 deco))})\n   (.define StateField)))\n\n(defn extension []\n  #js[base-theme\n      state\n      (.. EditorView -decorations (from state))])\n"]}